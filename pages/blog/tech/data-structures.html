<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ•°æ®ç»“æ„ï¼šé“¾è¡¨ã€æ ˆã€é˜Ÿåˆ—ã€ä¸² - HealthJiançš„åšå®¢</title>
    <!-- æ ¹æ®å®é™…è·¯å¾„è°ƒæ•´CSSå¼•ç”¨è·¯å¾„ -->
    <link rel="stylesheet" href="../../../css/style.css">
    <link rel="stylesheet" href="../../../css/dark-mode.css">
    <link rel="stylesheet" href="../../../css/blog-post.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css">
    <link href="https://fonts.googleapis.com/css2?family=SF+Pro+Display:wght@300;400;500;600&display=swap" rel="stylesheet">
</head>
<body class="light-mode">
    <!-- å¯¼èˆªæ  -->
    <nav class="navbar">
        <div class="nav-left">
            <!-- æ ¹æ®å®é™…éƒ¨ç½²çš„æ–‡ä»¶å¤¹æ·±åº¦è°ƒæ•´è·¯å¾„ -->
            <a href="../../../index.html" class="logo">
                <img src="../../../images/githubherofigureimage.png" alt="Logo">
                <span class="site-name" data-en="HealthJian Blog" data-zh="HealthJian">HealthJian</span>
            </a>
        </div>
        <div class="nav-right">
            <ul class="menu">
                <!-- æ ¹æ®å®é™…éƒ¨ç½²çš„æ–‡ä»¶å¤¹æ·±åº¦è°ƒæ•´è·¯å¾„ -->
                <li><a href="../../../index.html" data-en="Home" data-zh="é¦–é¡µ">é¦–é¡µ</a></li>
                <li><a href="../../../blog.html" data-en="Blog" data-zh="åšå®¢">åšå®¢</a></li>
                <li><a href="https://github.com/CaiNiaojian" target="_blank" data-en="GitHub" data-zh="GitHub">GitHub</a></li>
                <li><a href="../../../links.html" data-en="Links" data-zh="é“¾æ¥">é“¾æ¥</a></li>
                <li><a href="../../../about.html" data-en="About" data-zh="å…³äº">å…³äº</a></li>
            </ul>
            <div class="social-icons">
                <a href="https://steamcommunity.com/id/yoursteamid" target="_blank" title="Steam"><i class="fab fa-steam"></i></a>
                <a href="mailto:gaojian1573@foxmail.com" title="Email"><i class="fas fa-envelope"></i></a>
            </div>
            <button id="theme-toggle" class="theme-toggle" title="åˆ‡æ¢ä¸»é¢˜">
                <i class="fas fa-moon"></i>
                <i class="fas fa-sun"></i>
            </button>
            <button id="lang-toggle" class="lang-toggle" title="åˆ‡æ¢è¯­è¨€">
                <span data-en="EN" data-zh="ä¸­">ä¸­</span>
            </button>
        </div>
    </nav>

    <div class="blog-post-container">
        <!-- ä¾§è¾¹æ  -->
        <aside class="blog-sidebar">
            <div class="toc-container">
                <h3 data-en="Table of Contents" data-zh="ç›®å½•">ç›®å½•</h3>
                <ul class="toc-list">
                    <!-- æ–‡ç« ç›®å½•ï¼Œæ ¹æ®å®é™…å†…å®¹æ·»åŠ æˆ–ä¿®æ”¹ -->
                    <li><a href="#section-1" data-en="I. Introduction" data-zh="ä¸€ã€å¼•è¨€">ä¸€ã€å¼•è¨€</a></li>
                    <li><a href="#section-2" data-en="II. List" data-zh="äºŒã€é“¾è¡¨">äºŒã€é“¾è¡¨</a></li>
                    <li><a href="#section-3" data-en="III. Stack" data-zh="ä¸‰ã€æ ˆ">ä¸‰ã€æ ˆ</a></li>
                    <li><a href="#section-4" data-en="IV. Queue" data-zh="å››ã€é˜Ÿåˆ—">å››ã€é˜Ÿåˆ—</a></li>
                    <li><a href="#section-5" data-en="V. String" data-zh="äº”ã€ä¸²">äº”ã€ä¸²</a></li>
                    <!-- æ ¹æ®éœ€è¦æ·»åŠ æ›´å¤šç« èŠ‚ -->
                </ul>
            </div>
            
            <div class="post-meta-info">
                <div class="post-date">
                    <i class="far fa-calendar-alt"></i>
                    <span>2025-03-22</span> <!-- æ›´æ–°å®é™…å‘å¸ƒæ—¥æœŸ -->
                </div>
                <div class="post-tags">
                    <i class="fas fa-tags"></i>
                    <!-- æ ¹æ®æ–‡ç« ä¸»é¢˜ä¿®æ”¹æ ‡ç­¾ -->
                    <span class="tag" data-en="data-structure" data-zh="æ•°æ®ç»“æ„">æ•°æ®ç»“æ„</span>
                    <span class="tag" data-en="basic-knowledge" data-zh="åŸºç¡€çŸ¥è¯†">åŸºç¡€çŸ¥è¯†</span>
                    <span class="tag" data-en="note" data-zh="ç¬”è®°">ç¬”è®°</span>
                </div>
                <div class="post-category">
                    <i class="fas fa-folder"></i>
                    <!-- ä¿®æ”¹ä¸ºå®é™…åˆ†ç±» -->
                    <span data-en="tech" data-zh="æŠ€æœ¯">æŠ€æœ¯</span>
                </div>
            </div>
            
            <div class="post-navigation">
                <h3 data-en="Navigation" data-zh="å¯¼èˆª">å¯¼èˆª</h3>
                <div class="nav-buttons">
                    <a href="../blog.html" class="nav-button" data-en="Back to Blog" data-zh="è¿”å›åšå®¢åˆ—è¡¨">
                        <i class="fas fa-arrow-left"></i>
                        <span data-en="Back to Blog" data-zh="è¿”å›åšå®¢åˆ—è¡¨">è¿”å›åšå®¢åˆ—è¡¨</span>
                    </a>
                </div>
            </div>
        </aside>

        <!-- æ–‡ç« ä¸»ä½“ -->
        <main class="blog-post-main">
            <article class="blog-post-content">
                <header class="post-header">
                    <h1 class="post-title">
                        <div class="bilingual-content">
                            <span class="zh-content">æ•°æ®ç»“æ„ï¼šé“¾è¡¨ã€æ ˆã€é˜Ÿåˆ—ã€ä¸²</span>
                            <span class="en-content" style="display: none;">Data Structures: Linked List, Stack, Queue, String</span>
                        </div>
                    </h1>
                </header>
                
                <div class="post-body">
                    <!-- ç¬¬ä¸€éƒ¨åˆ†ï¼šå¼•è¨€ -->
                    <section id="section-1">
                        <h2 data-en="I. Introduction" data-zh="ä¸€ã€å¼•è¨€">ä¸€ã€å¼•è¨€</h2>
                        
                        <div class="bilingual-content">
                            <p class="zh-content">æ•°æ®ç»“æ„æ˜¯è®¡ç®—æœºå­˜å‚¨ä¸ç»„ç»‡æ•°æ®çš„é€»è¾‘æ¡†æ¶ï¼Œä¸ºç®—æ³•è®¾è®¡å¥ å®šåŸºç¡€ã€‚åœ¨å­¦ä¹ æ•°æ®ç»“æ„çš„è¿‡ç¨‹ä¸­ï¼Œé“¾è¡¨ã€æ ˆã€é˜Ÿåˆ—ã€ä¸²æ˜¯å¿…å­¦çš„ã€‚è¿™éƒ¨åˆ†æ˜¯å¾ªåºæ¸è¿›ï¼Œç”±æµ…å…¥æ·±çš„è¿‡ç¨‹ã€‚åè€…æ˜¯è¡¨çš„æ‰©å±•å’Œå¯¹ç‰¹å®šåº”ç”¨å¯¹è±¡äº§ç”Ÿçš„æŠ€æœ¯ï¼Œæœ¬è´¨æ˜¯è¡¨çš„æŠ½è±¡ã€‚</p>
                            
                            <p class="en-content" style="display: none;">Data structures provide logical frameworks for storing and organizing data, forming the foundation of algorithm design.Chained lists, stacks, queues, and strings are mandatory in learning data structures. This part is a gradual, step-by-step process. The latter is an extension of the table and the technology generated for specific application objects, the essence is the abstraction of the table.</p>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content">é“¾è¡¨é€šè¿‡èŠ‚ç‚¹æŒ‡é’ˆå®ç°åŠ¨æ€å†…å­˜åˆ†é…ï¼Œæ”¯æŒé«˜æ•ˆçš„æ’å…¥ä¸åˆ é™¤æ“ä½œã€‚æ ˆéµå¾ªåè¿›å…ˆå‡ºåŸåˆ™ï¼Œåœ¨å‡½æ•°è°ƒç”¨å’Œè¡¨è¾¾å¼æ±‚å€¼ä¸­å‘æŒ¥å…³é”®ä½œç”¨ã€‚é˜Ÿåˆ—é‡‡ç”¨å…ˆè¿›å…ˆå‡ºæœºåˆ¶ï¼Œå¹¿æ³›åº”ç”¨äºä»»åŠ¡è°ƒåº¦å’Œç¼“å†²ç®¡ç†ã€‚ä¸²ä½œä¸ºç‰¹æ®Šçº¿æ€§ç»“æ„ï¼Œå…¶æ¨¡å¼åŒ¹é…ç®—æ³•æ·±åˆ»å½±å“ç€æ–‡æœ¬å¤„ç†é¢†åŸŸã€‚è¿™äº›åŸºç¡€ç»“æ„å…±åŒæ„å»ºäº†å¤æ‚ç®—æ³•çš„å®ç°åŸºçŸ³ã€‚ğŸ˜€</p>
                            
                            <p class="en-content" style="display: none;">Linked lists utilize node pointers for dynamic memory allocation, enabling efficient insertion and deletion operations.Stacks follow the Last-In-First-Out principle, playing vital roles in function calls and expression evaluation.Queues employ the First-In-First-Out mechanism, widely applied in task scheduling and buffer manag. Strings, as specialized linear structures, significantly influence text processing through pattern matching algorithms.ement.These fundamental structures collectively form the cornerstone for implementing complex algorithms.ğŸ˜€</p>
                        </div>

                        <div class="post-image">
                            <img src="../../../images/bluesky.avif" alt="å¤©ç©º" class="responsive-image">
                            <figcaption data-en="The sky" data-zh="å¤©ç©º">å¤©ç©º <span class="emoji">ğŸŒ™</span></figcaption>
                        </div>

                        <div class="bilingual-content">
                            <p class="zh-content">ä¸‹æ–‡æˆ‘å°†ç»“åˆæˆ‘æœ€è¿‘å­¦ä¹ çš„ç»éªŒï¼Œä»¥åŠåº”è¯•è§’åº¦çš„æƒ³æ³•è¿›è¡Œåˆ†äº«ã€‚ğŸŒ¹</p>
                            
                            <p class="en-content" style="display: none;">Below I will share my thoughts on my recent study experience, as well as my thoughts from a test-taking perspective.ğŸŒ¹</p>
                        </div>
                    </section>
                    
                    <!-- ç¬¬äºŒéƒ¨åˆ† -->
                    <section id="section-2">
                        <h2 data-en="II. Linear List and Linked List" data-zh="äºŒã€çº¿æ€§è¡¨ä¸é“¾è¡¨">äºŒã€çº¿æ€§è¡¨ä¸é“¾è¡¨</h2>
                        
                        <h3 data-en="2.1 Sequential List" data-zh="2.1 é¡ºåºè¡¨">2.1 é¡ºåºè¡¨</h3>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>é¡ºåºè¡¨æ¦‚å¿µ</strong><br>
                            é¡ºåºè¡¨æ˜¯çº¿æ€§è¡¨çš„ä¸€ç§å®ç°æ–¹å¼ï¼Œå®ƒä½¿ç”¨ä¸€æ®µè¿ç»­çš„å†…å­˜ç©ºé—´å­˜å‚¨çº¿æ€§è¡¨ä¸­çš„å…ƒç´ ã€‚åœ¨è®¡ç®—æœºä¸­ï¼Œé€šå¸¸ä½¿ç”¨æ•°ç»„æ¥å®ç°é¡ºåºè¡¨ã€‚é¡ºåºè¡¨çš„ç‰¹ç‚¹æ˜¯æ”¯æŒéšæœºè®¿é—®ï¼Œå³å¯ä»¥åœ¨O(1)æ—¶é—´å†…è®¿é—®ä»»æ„ä½ç½®çš„å…ƒç´ ã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>Sequential List Concept</strong><br>
                            A sequential list is an implementation of a linear list that uses a contiguous memory space to store elements. In computers, arrays are typically used to implement sequential lists. The characteristic of sequential lists is that they support random access, meaning any element can be accessed in O(1) time.</p>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>é¡ºåºè¡¨çš„åŸºæœ¬æ“ä½œåŠæ—¶é—´å¤æ‚åº¦</strong><br>
                            â€¢ æŸ¥æ‰¾ï¼šO(1)ï¼Œå¯ä»¥ç›´æ¥é€šè¿‡ç´¢å¼•è®¿é—®<br>
                            <div class="code-block">
<pre><code class="language-c">// Cè¯­è¨€å®ç°æŸ¥æ‰¾æ“ä½œ
int findElement(int arr[], int size, int index) {
    if(index >= 0 && index < size)
        return arr[index];  // O(1)æ—¶é—´å¤æ‚åº¦
    return -1;  // ç´¢å¼•æ— æ•ˆ
}</code></pre>
                            </div><br>
                            â€¢ æ’å…¥ï¼šå¹³å‡O(n)ï¼Œéœ€è¦ç§»åŠ¨æ’å…¥ä½ç½®åçš„æ‰€æœ‰å…ƒç´ <br>
                            <div class="code-block">
<pre><code class="language-c">// Cè¯­è¨€å®ç°æ’å…¥æ“ä½œ
void insertElement(int arr[], int size, int pos, int value) {
    // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿç©ºé—´å’Œä½ç½®æ˜¯å¦æœ‰æ•ˆ
    if (pos < 0 || pos > size) return;
    
    // ä»æœ€åä¸€ä¸ªå…ƒç´ å¼€å§‹å‘åç§»åŠ¨
    for(int i = size; i > pos; i--) {
        arr[i] = arr[i-1];  // å…ƒç´ åç§»
    }
    arr[pos] = value;  // æ’å…¥æ–°å…ƒç´ 
}</code></pre>
                            </div><br>
                            â€¢ åˆ é™¤ï¼šå¹³å‡O(n)ï¼Œéœ€è¦ç§»åŠ¨åˆ é™¤ä½ç½®åçš„æ‰€æœ‰å…ƒç´ <br>
                            <div class="code-block">
<pre><code class="language-c">// Cè¯­è¨€å®ç°åˆ é™¤æ“ä½œ
void deleteElement(int arr[], int* size, int pos) {
    // æ£€æŸ¥ä½ç½®æ˜¯å¦æœ‰æ•ˆ
    if (pos < 0 || pos >= *size) return;
    
    // å°†åˆ é™¤ä½ç½®åçš„å…ƒç´ å‰ç§»
    for(int i = pos; i < *size - 1; i++) {
        arr[i] = arr[i+1];
    }
    (*size)--;  // å‡å°æ•°ç»„å¤§å°
}</code></pre>
                            </div><br>
                            â€¢ ä¿®æ”¹ï¼šO(1)ï¼Œç›´æ¥é€šè¿‡ç´¢å¼•ä¿®æ”¹<br>
                            <div class="code-block">
<pre><code class="language-c">// Cè¯­è¨€å®ç°ä¿®æ”¹æ“ä½œ
void modifyElement(int arr[], int size, int index, int newValue) {
    if(index >= 0 && index < size)
        arr[index] = newValue;  // O(1)æ—¶é—´å¤æ‚åº¦
}</code></pre>
                            </div></p>
                            
                            <p class="en-content" style="display: none;"><strong>Basic Operations and Time Complexity of Sequential Lists</strong><br>
                            â€¢ Search: O(1), direct access through index<br>
                            â€¢ Insert: Average O(n), requires moving all elements after the insertion position<br>
                            â€¢ Delete: Average O(n), requires moving all elements after the deletion position<br>
                            â€¢ Modify: O(1), direct modification through index</p>
                        </div>
                        
                        <h3 data-en="2.2 Linked List Introduction" data-zh="2.2 é“¾è¡¨å¼•å…¥">2.2 é“¾è¡¨å¼•å…¥</h3>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>ä»é¡ºåºè¡¨åˆ°é“¾è¡¨</strong><br>
                            é¡ºåºè¡¨è™½ç„¶æ”¯æŒå¿«é€Ÿçš„éšæœºè®¿é—®ï¼Œä½†åœ¨æ’å…¥å’Œåˆ é™¤æ“ä½œæ—¶æ•ˆç‡è¾ƒä½ã€‚é“¾è¡¨é€šè¿‡ä½¿ç”¨ä¸è¿ç»­çš„å†…å­˜ç©ºé—´ï¼Œæ¯ä¸ªèŠ‚ç‚¹åŒ…å«æ•°æ®åŸŸå’ŒæŒ‡é’ˆåŸŸï¼Œè§£å†³äº†é¡ºåºè¡¨çš„è¿™ä¸€ç¼ºç‚¹ã€‚é“¾è¡¨ä¸­çš„èŠ‚ç‚¹é€šè¿‡æŒ‡é’ˆç›¸äº’è¿æ¥ï¼Œå½¢æˆä¸€ä¸ªçº¿æ€§ç»“æ„ã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>From Sequential List to Linked List</strong><br>
                            Although sequential lists support fast random access, they are inefficient for insertion and deletion operations. Linked lists solve this disadvantage by using non-contiguous memory spaces, with each node containing a data field and a pointer field. Nodes in a linked list are connected through pointers, forming a linear structure.</p>
                        </div>
                        
                        <h3 data-en="2.3 Singly Linked List" data-zh="2.3 å•å‘é“¾è¡¨">2.3 å•å‘é“¾è¡¨</h3>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>å•å‘é“¾è¡¨çš„ç»“æ„</strong><br>
                            å•å‘é“¾è¡¨ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹åŒ…å«ä¸¤éƒ¨åˆ†ï¼šæ•°æ®åŸŸå’ŒæŒ‡é’ˆåŸŸã€‚æŒ‡é’ˆåŸŸå­˜å‚¨æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆã€‚é“¾è¡¨é€šå¸¸æœ‰ä¸€ä¸ªå¤´æŒ‡é’ˆï¼ŒæŒ‡å‘é“¾è¡¨çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆåŸŸä¸ºç©ºï¼ˆNULLï¼‰ï¼Œè¡¨ç¤ºé“¾è¡¨ç»“æŸã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>Structure of Singly Linked List</strong><br>
                            Each node in a singly linked list contains two parts: a data field and a pointer field. The pointer field stores a pointer to the next node. A linked list typically has a head pointer pointing to the first node. The pointer field of the last node is NULL, indicating the end of the list.</p>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>å•å‘é“¾è¡¨çš„åŸºæœ¬æ“ä½œåŠæ—¶é—´å¤æ‚åº¦</strong><br>
                            â€¢ æŸ¥æ‰¾ï¼šO(n)ï¼Œéœ€è¦ä»å¤´èŠ‚ç‚¹å¼€å§‹éå†<br>
                            <div class="code-block">
<pre><code class="language-c">// Cè¯­è¨€å®ç°æŸ¥æ‰¾æ“ä½œ
Node* findElement(Node* head, int value) {
    Node* current = head;
    while (current != NULL) {
        if (current->data == value)
            return current;
        current = current->next;
    }
    return NULL;  // æœªæ‰¾åˆ°
}</code></pre>
                            </div><br>
                            â€¢ æ’å…¥ï¼šO(1)ï¼Œå¦‚æœå·²çŸ¥æ’å…¥ä½ç½®çš„å‰ä¸€ä¸ªèŠ‚ç‚¹<br>
                            <div class="code-block">
<pre><code class="language-c">// Cè¯­è¨€å®ç°æ’å…¥æ“ä½œ
void insertAfter(Node* prevNode, int newValue) {
    if (prevNode == NULL) return;
    
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = newValue;
    newNode->next = prevNode->next;
    prevNode->next = newNode;
}</code></pre>
                            </div><br>
                            â€¢ åˆ é™¤ï¼šO(1)ï¼Œå¦‚æœå·²çŸ¥åˆ é™¤ä½ç½®çš„å‰ä¸€ä¸ªèŠ‚ç‚¹<br>
                            <div class="code-block">
<pre><code class="language-c">// Cè¯­è¨€å®ç°åˆ é™¤æ“ä½œ
void deleteAfter(Node* prevNode) {
    if (prevNode == NULL || prevNode->next == NULL)
        return;
    
    Node* toDelete = prevNode->next;
    prevNode->next = toDelete->next;
    free(toDelete);
}</code></pre>
                            </div><br>
                            â€¢ ä¿®æ”¹ï¼šO(n)ï¼Œéœ€è¦å…ˆæŸ¥æ‰¾åˆ°èŠ‚ç‚¹<br>
                            <div class="code-block">
<pre><code class="language-c">// Cè¯­è¨€å®ç°ä¿®æ”¹æ“ä½œ
int modifyElement(Node* head, int oldValue, int newValue) {
    Node* current = head;
    while (current != NULL) {
        if (current->data == oldValue) {
            current->data = newValue;
            return 1;
        }
        current = current->next;
    }
    return 0;  // æœªæ‰¾åˆ°è¦ä¿®æ”¹çš„å…ƒç´ 
}</code></pre>
                            </div></p>
                            
                            <p class="en-content" style="display: none;"><strong>Basic Operations and Time Complexity of Singly Linked Lists</strong><br>
                            â€¢ Search: O(n), requires traversal from the head node<br>
                            â€¢ Insert: O(1), if the previous node of the insertion position is known<br>
                            â€¢ Delete: O(1), if the previous node of the deletion position is known<br>
                            â€¢ Modify: O(n), requires finding the node first</p>
                        </div>
                        
                        <h3 data-en="2.4 Doubly Linked List" data-zh="2.4 åŒå‘é“¾è¡¨">2.4 åŒå‘é“¾è¡¨</h3>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>åŒå‘é“¾è¡¨çš„ç»“æ„</strong><br>
                            åŒå‘é“¾è¡¨ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹åŒ…å«ä¸‰éƒ¨åˆ†ï¼šæ•°æ®åŸŸã€å‰é©±æŒ‡é’ˆå’Œåç»§æŒ‡é’ˆã€‚å‰é©±æŒ‡é’ˆæŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œåç»§æŒ‡é’ˆæŒ‡å‘åä¸€ä¸ªèŠ‚ç‚¹ã€‚åŒå‘é“¾è¡¨å¯ä»¥ä»ä¸¤ä¸ªæ–¹å‘éå†ï¼Œå¢åŠ äº†çµæ´»æ€§ã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>Structure of Doubly Linked List</strong><br>
                            Each node in a doubly linked list contains three parts: a data field, a previous pointer, and a next pointer. The previous pointer points to the previous node, and the next pointer points to the next node. Doubly linked lists can be traversed in both directions, adding flexibility.</p>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>åŒå‘é“¾è¡¨çš„åŸºæœ¬æ“ä½œåŠæ—¶é—´å¤æ‚åº¦</strong><br>
                            â€¢ æŸ¥æ‰¾ï¼šO(n)ï¼Œå¯ä»¥ä»å¤´æˆ–å°¾å¼€å§‹éå†<br>
                            <div class="code-block">
<pre><code class="language-c">// Cè¯­è¨€å®ç°åŒå‘é“¾è¡¨æŸ¥æ‰¾æ“ä½œ
Node* search(Node* head, int value) {
    Node* current = head;
    while (current != NULL) {
        if (current->data == value)
            return current;
        current = current->next;
    }
    return NULL;  // æœªæ‰¾åˆ°å…ƒç´ 
}</code></pre>
                            </div><br>
                            â€¢ æ’å…¥ï¼šO(1)ï¼Œå¦‚æœå·²çŸ¥æ’å…¥ä½ç½®çš„èŠ‚ç‚¹<br>
                            <div class="code-block">
<pre><code class="language-c">// Cè¯­è¨€å®ç°åŒå‘é“¾è¡¨æ’å…¥æ“ä½œ
void insertAfter(Node* node, int value) {
    if (node == NULL) return;
    
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = value;
    
    newNode->next = node->next;
    newNode->prev = node;
    
    if (node->next != NULL)
        node->next->prev = newNode;
        
    node->next = newNode;
}</code></pre>
                            </div><br>
                            â€¢ åˆ é™¤ï¼šO(1)ï¼Œå¦‚æœå·²çŸ¥åˆ é™¤ä½ç½®çš„èŠ‚ç‚¹<br>
                            <div class="code-block">
<pre><code class="language-c">// Cè¯­è¨€å®ç°åŒå‘é“¾è¡¨åˆ é™¤æ“ä½œ
void deleteNode(Node* node) {
    if (node == NULL) return;
    
    if (node->prev != NULL)
        node->prev->next = node->next;
        
    if (node->next != NULL)
        node->next->prev = node->prev;
        
    free(node);
}</code></pre>
                            </div><br>
                            â€¢ ä¿®æ”¹ï¼šO(n)ï¼Œéœ€è¦å…ˆæŸ¥æ‰¾åˆ°èŠ‚ç‚¹<br>
                            <div class="code-block">
<pre><code class="language-c">// Cè¯­è¨€å®ç°åŒå‘é“¾è¡¨ä¿®æ”¹æ“ä½œ
int modifyElement(Node* head, int oldValue, int newValue) {
    Node* node = search(head, oldValue);
    if (node != NULL) {
        node->data = newValue;
        return 1;
    }
    return 0;  // æœªæ‰¾åˆ°è¦ä¿®æ”¹çš„å…ƒç´ 
}</code></pre>
                            </div></p>
                            
                            <p class="en-content" style="display: none;"><strong>Basic Operations and Time Complexity of Doubly Linked Lists</strong><br>
                            â€¢ Search: O(n), can traverse from either head or tail<br>
                            â€¢ Insert: O(1), if the node at the insertion position is known<br>
                            â€¢ Delete: O(1), if the node at the deletion position is known<br>
                            â€¢ Modify: O(n), requires finding the node first</p>
                        </div>
                        
                        <h3 data-en="2.5 Common Algorithm Problems" data-zh="2.5 å¸¸è§ç®—æ³•é¢˜å‹">2.5 å¸¸è§ç®—æ³•é¢˜å‹</h3>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>1. æœ‰åºé“¾è¡¨åˆå¹¶</strong><br>
                            å°†ä¸¤ä¸ªå·²æ’åºçš„é“¾è¡¨åˆå¹¶ä¸ºä¸€ä¸ªæ–°çš„æœ‰åºé“¾è¡¨ã€‚è¿™æ˜¯ä¸€ä¸ªå¸¸è§çš„åŸºç¡€ç®—æ³•é—®é¢˜ï¼Œä¹Ÿæ˜¯å½’å¹¶æ’åºçš„æ ¸å¿ƒæ“ä½œã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>1. Merge Two Sorted Lists</strong><br>
                            Merge two sorted linked lists into a new sorted list. This is a common fundamental algorithm problem and also the core operation of merge sort.</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ï¼ˆCè¯­è¨€ï¼‰
struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) {
    struct ListNode dummy;
    struct ListNode* tail = &dummy;
    
    while (l1 && l2) {
        if (l1->val < l2->val) {
            tail->next = l1;
            l1 = l1->next;
        } else {
            tail->next = l2;
            l2 = l2->next;
        }
        tail = tail->next;
    }
    
    tail->next = l1 ? l1 : l2;
    return dummy.next;
}</code></pre>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>2. é“¾è¡¨é›†åˆæ“ä½œ - äº¤é›†</strong><br>
                            ç»™å®šä¸¤ä¸ªé“¾è¡¨ï¼Œæ±‚å®ƒä»¬çš„äº¤é›†ï¼ˆå³åœ¨ä¸¤ä¸ªé“¾è¡¨ä¸­éƒ½å‡ºç°çš„å…ƒç´ ï¼‰ã€‚é€šå¸¸å‡è®¾é“¾è¡¨ä¸­æ— é‡å¤å…ƒç´ ã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>2. Linked List Set Operations - Intersection</strong><br>
                            Given two linked lists, find their intersection (elements that appear in both lists). Usually assumes no duplicate elements in the lists.</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// æ±‚ä¸¤ä¸ªé“¾è¡¨çš„äº¤é›†ï¼ˆCè¯­è¨€ï¼‰
struct ListNode* getIntersection(struct ListNode* headA, struct ListNode* headB) {
    // ä½¿ç”¨å“ˆå¸Œè¡¨å­˜å‚¨ç¬¬ä¸€ä¸ªé“¾è¡¨çš„å€¼
    int hash[10000] = {0}; // å‡è®¾å€¼çš„èŒƒå›´åœ¨0-9999ä¹‹é—´
    struct ListNode dummy;
    struct ListNode* tail = &dummy;
    dummy.next = NULL;
    
    // å°†ç¬¬ä¸€ä¸ªé“¾è¡¨çš„æ‰€æœ‰å€¼æ ‡è®°åœ¨å“ˆå¸Œè¡¨ä¸­
    while (headA) {
        hash[headA->val] = 1;
        headA = headA->next;
    }
    
    // æ£€æŸ¥ç¬¬äºŒä¸ªé“¾è¡¨ä¸­çš„å€¼æ˜¯å¦åœ¨å“ˆå¸Œè¡¨ä¸­
    while (headB) {
        if (hash[headB->val] == 1) {
            struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));
            newNode->val = headB->val;
            newNode->next = NULL;
            
            tail->next = newNode;
            tail = tail->next;
            hash[headB->val] = 0; // é˜²æ­¢é‡å¤æ·»åŠ 
        }
        headB = headB->next;
    }
    
    return dummy.next;
}</code></pre>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>3. é“¾è¡¨é›†åˆæ“ä½œ - å¹¶é›†</strong><br>
                            ç»™å®šä¸¤ä¸ªé“¾è¡¨ï¼Œæ±‚å®ƒä»¬çš„å¹¶é›†ï¼ˆå³åŒ…å«ä¸¤ä¸ªé“¾è¡¨ä¸­æ‰€æœ‰ä¸é‡å¤çš„å…ƒç´ ï¼‰ã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>3. Linked List Set Operations - Union</strong><br>
                            Given two linked lists, find their union (all unique elements from both lists).</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// æ±‚ä¸¤ä¸ªé“¾è¡¨çš„å¹¶é›†ï¼ˆCè¯­è¨€ï¼‰
struct ListNode* getUnion(struct ListNode* headA, struct ListNode* headB) {
    int hash[10000] = {0}; // å‡è®¾å€¼çš„èŒƒå›´åœ¨0-9999ä¹‹é—´
    struct ListNode dummy;
    struct ListNode* tail = &dummy;
    dummy.next = NULL;
    
    // å¤„ç†ç¬¬ä¸€ä¸ªé“¾è¡¨
    while (headA) {
        if (hash[headA->val] == 0) {
            hash[headA->val] = 1;
            
            struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));
            newNode->val = headA->val;
            newNode->next = NULL;
            
            tail->next = newNode;
            tail = tail->next;
        }
        headA = headA->next;
    }
    
    // å¤„ç†ç¬¬äºŒä¸ªé“¾è¡¨
    while (headB) {
        if (hash[headB->val] == 0) {
            hash[headB->val] = 1;
            
            struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));
            newNode->val = headB->val;
            newNode->next = NULL;
            
            tail->next = newNode;
            tail = tail->next;
        }
        headB = headB->next;
    }
    
    return dummy.next;
}</code></pre>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>4. é“¾è¡¨é›†åˆæ“ä½œ - è¡¥é›†</strong><br>
                            ç»™å®šä¸¤ä¸ªé“¾è¡¨Aå’ŒBï¼Œæ±‚Aç›¸å¯¹äºBçš„è¡¥é›†ï¼ˆå³åœ¨Aä¸­å‡ºç°ä½†ä¸åœ¨Bä¸­å‡ºç°çš„å…ƒç´ ï¼‰ã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>4. Linked List Set Operations - Complement</strong><br>
                            Given two linked lists A and B, find the complement of A with respect to B (elements that appear in A but not in B).</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// æ±‚é“¾è¡¨Aç›¸å¯¹äºBçš„è¡¥é›†ï¼ˆCè¯­è¨€ï¼‰
struct ListNode* getComplement(struct ListNode* headA, struct ListNode* headB) {
    int hash[10000] = {0}; // å‡è®¾å€¼çš„èŒƒå›´åœ¨0-9999ä¹‹é—´
    struct ListNode dummy;
    struct ListNode* tail = &dummy;
    dummy.next = NULL;
    
    // å°†Bä¸­æ‰€æœ‰å…ƒç´ æ ‡è®°åœ¨å“ˆå¸Œè¡¨ä¸­
    while (headB) {
        hash[headB->val] = 1;
        headB = headB->next;
    }
    
    // æ£€æŸ¥Aä¸­çš„å…ƒç´ æ˜¯å¦ä¸åœ¨Bä¸­
    while (headA) {
        if (hash[headA->val] == 0) {
            struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));
            newNode->val = headA->val;
            newNode->next = NULL;
            
            tail->next = newNode;
            tail = tail->next;
        }
        headA = headA->next;
    }
    
    return dummy.next;
}</code></pre>
                        </div>
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>5. é“¾è¡¨åè½¬</strong><br>
                            å°†ä¸€ä¸ªå•å‘é“¾è¡¨åè½¬ï¼Œä½¿æ‰€æœ‰èŠ‚ç‚¹çš„æŒ‡å‘åå‘ã€‚è¿™æ˜¯é¢è¯•ä¸­çš„ç»å…¸é—®é¢˜ã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>5. Linked List Reversal</strong><br>
                            Reverse a singly linked list, changing the direction of all node pointers. This is a classic interview problem.</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// é“¾è¡¨åè½¬ä»£ç ç¤ºä¾‹ï¼ˆCè¯­è¨€ï¼‰
struct ListNode* reverseList(struct ListNode* head) {
    struct ListNode* prev = NULL;
    struct ListNode* curr = head;
    while (curr != NULL) {
        struct ListNode* next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}</code></pre>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>6. æ£€æµ‹ç¯å½¢é“¾è¡¨</strong><br>
                            åˆ¤æ–­ä¸€ä¸ªé“¾è¡¨æ˜¯å¦åŒ…å«ç¯ã€‚å¯ä»¥ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆï¼ˆFloyd's Cycle-Finding Algorithmï¼‰è§£å†³ã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>6. Detecting Cycle in a Linked List</strong><br>
                            Determine if a linked list contains a cycle. This can be solved using the fast and slow pointer technique (Floyd's Cycle-Finding Algorithm).</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// æ£€æµ‹ç¯å½¢é“¾è¡¨ä»£ç ç¤ºä¾‹ï¼ˆCè¯­è¨€ï¼‰
bool hasCycle(struct ListNode* head) {
    if (head == NULL || head->next == NULL) return false;
    
    struct ListNode* slow = head;
    struct ListNode* fast = head;
    
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) return true;
    }
    
    return false;
}</code></pre>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>7. æ‰¾å‡ºé“¾è¡¨çš„ä¸­é—´èŠ‚ç‚¹</strong><br>
                            æ‰¾å‡ºå•å‘é“¾è¡¨çš„ä¸­é—´èŠ‚ç‚¹ã€‚åŒæ ·å¯ä»¥ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆè§£å†³ã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>7. Finding the Middle Node of a Linked List</strong><br>
                            Find the middle node of a singly linked list. This can also be solved using the fast and slow pointer technique.</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// æ‰¾å‡ºé“¾è¡¨ä¸­é—´èŠ‚ç‚¹ä»£ç ç¤ºä¾‹ï¼ˆCè¯­è¨€ï¼‰
struct ListNode* middleNode(struct ListNode* head) {
    struct ListNode* slow = head;
    struct ListNode* fast = head;
    
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
    }
    
    return slow;
}</code></pre>
                        </div>
                        
                        <!-- ä»£ç ç¤ºä¾‹ï¼ˆå¦‚æœéœ€è¦ï¼‰ -->
                        <div class="code-block">
                            <pre><code class="language-c">// æ­¤å¤„æ·»åŠ ä»£ç ç¤ºä¾‹
void example() {
    printf("Hello, World!\n");
}</code></pre>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>ç¤ºä¾‹åˆ†æ</strong><br>
                            åˆ†æä¸Šè¿°ä»£ç æˆ–æ¦‚å¿µçš„åº”ç”¨ç¤ºä¾‹ï¼š</p>
                            
                            <p class="en-content" style="display: none;"><strong>Example Analysis</strong><br>
                            Analyze the application examples of the above code or concepts:</p>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>æ€»ç»“</strong><br>
                            å°èŠ‚å†…å®¹æ€»ç»“ <span class="emoji">ğŸ“</span></p>
                            
                            <p class="en-content" style="display: none;"><strong>Summary</strong><br>
                            Summary of the subsection content <span class="emoji">ğŸ“</span></p>
                        </div>
                        
                        <h3 data-en="2.2 Subsection Two" data-zh="2.2 å°èŠ‚äºŒ">2.2 å°èŠ‚äºŒ</h3>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>æ¦‚å¿µè§£é‡Š</strong><br>
                            åœ¨æ­¤å¤„è§£é‡Šç›¸å…³æ¦‚å¿µ</p>
                            
                            <p class="en-content" style="display: none;"><strong>Concept Explanation</strong><br>
                            Explain related concepts here</p>
                        </div>
                        
                        <!-- å›¾ç‰‡ç¤ºä¾‹ï¼ˆå¦‚æœéœ€è¦ï¼‰--> 
                        <div class="post-image">
                            <img src="../../images/example.jpg" alt="ç¤ºä¾‹å›¾ç‰‡" class="responsive-image">
                            <figcaption data-en="Example Image" data-zh="ç¤ºä¾‹å›¾ç‰‡">ç¤ºä¾‹å›¾ç‰‡</figcaption>
                        </div>
                    </section>
                    
                    <!-- ç¬¬ä¸‰éƒ¨åˆ† -->
                    <section id="section-3">
                        <h2 data-en="III. Section Three" data-zh="ä¸‰ã€ç¬¬ä¸‰éƒ¨åˆ†">ä¸‰ã€ç¬¬ä¸‰éƒ¨åˆ†</h2>
                        
                        <div class="bilingual-content">
                            <p class="zh-content">æ­¤å¤„æ·»åŠ ç¬¬ä¸‰éƒ¨åˆ†çš„å†…å®¹ã€‚å¯ä»¥åŒ…å«æ®µè½ã€åˆ—è¡¨ã€ä»£ç ç¤ºä¾‹ç­‰ã€‚</p>
                            
                            <p class="en-content" style="display: none;">Add content for section three here. Can include paragraphs, lists, code examples, etc.</p>
                        </div>
                        
                        <!-- åˆ—è¡¨ç¤ºä¾‹ -->
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>è¦ç‚¹åˆ—è¡¨ï¼š</strong></p>
                            <ul class="zh-content">
                                <li>ç¬¬ä¸€ä¸ªè¦ç‚¹</li>
                                <li>ç¬¬äºŒä¸ªè¦ç‚¹</li>
                                <li>ç¬¬ä¸‰ä¸ªè¦ç‚¹</li>
                            </ul>
                            
                            <p class="en-content" style="display: none;"><strong>Key Points:</strong></p>
                            <ul class="en-content" style="display: none;">
                                <li>First point</li>
                                <li>Second point</li>
                                <li>Third point</li>
                            </ul>
                        </div>
                    </section>
                    
                    <!-- ç»“è¯­ -->
                    <div class="post-conclusion">
                        <h2 data-en="Conclusion" data-zh="ç»“è¯­">ç»“è¯­</h2>
                        
                        <div class="bilingual-content">
                            <p class="zh-content">æ€»ç»“æ–‡ç« çš„ä¸»è¦è§‚ç‚¹å’Œç»“è®ºã€‚æä¾›è¿›ä¸€æ­¥æ€è€ƒæˆ–åç»­å­¦ä¹ çš„å»ºè®®ã€‚</p>
                            
                            <p class="en-content" style="display: none;">Summarize the main points and conclusions of the article. Provide suggestions for further thinking or subsequent learning.</p>
                            
                            <p class="zh-content">æ„Ÿè°¢é˜…è¯»ï¼å¦‚æœ‰é—®é¢˜æˆ–å»ºè®®ï¼Œæ¬¢è¿åœ¨è¯„è®ºåŒºç•™è¨€ã€‚ <span class="emoji">ğŸ’»âœ¨</span></p>
                            
                            <p class="en-content" style="display: none;">Thanks for reading! If you have any questions or suggestions, please leave a message in the comments section. <span class="emoji">ğŸ’»âœ¨</span></p>
                        </div>
                        
                        <div class="post-signature">
                            <p>â€” HealthJian <span class="emoji">âœï¸</span></p>
                        </div>
                    </div>
                </div>
            </article>
            
            <!-- è¯„è®ºåŒº -->
            <div class="comments-section">
                <h3 data-en="Comments" data-zh="è¯„è®º">è¯„è®º</h3>
                <div class="comment-form">
                    <textarea placeholder="å†™ä¸‹ä½ çš„æƒ³æ³•..." data-en-placeholder="Write your thoughts..." data-zh-placeholder="å†™ä¸‹ä½ çš„æƒ³æ³•..."></textarea>
                    <button data-en="Submit" data-zh="æäº¤">æäº¤</button>
                </div>
                <div class="comments-container">
                    <p class="no-comments" data-en="Be the first to comment!" data-zh="æˆä¸ºç¬¬ä¸€ä¸ªè¯„è®ºçš„äººï¼">æˆä¸ºç¬¬ä¸€ä¸ªè¯„è®ºçš„äººï¼ <span class="emoji">ğŸ‰</span></p>
                </div>
            </div>
        </main>
    </div>

    <!-- é¡µè„š -->
    <footer>
        <div class="footer-content">
            <div class="footer-info">
                <p>&copy; 2025 CaiNiaojian&HealthJian all followed.</p>
                <p data-en="Contact: " data-zh="è”ç³»æ–¹å¼ï¼š">è”ç³»æ–¹å¼ï¼š<a href="mailto:gaojian1573@foxmail.com">gaojian1573@foxmail.com</a></p>
                <p data-en="Location: " data-zh="åœ°å€ï¼š">åœ°å€ï¼šXX</p>
            </div>
            <div class="footer-links">
                <a href="../../../blog.html" data-en="Blog" data-zh="åšå®¢">åšå®¢</a>
                <a href="../../../about.html" data-en="About" data-zh="å…³äº">å…³äº</a>
                <a href="https://github.com/CaiNiaojian" target="_blank" data-en="GitHub" data-zh="GitHub">GitHub</a>
                <a href="../../../changelog.html" data-en="ChangeLog" data-zh="æ›´æ–°æ—¥å¿—">æ›´æ–°æ—¥å¿—</a>
            </div>
        </div>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // åˆå§‹åŒ–ä»£ç é«˜äº®
            hljs.highlightAll();
        });
    </script>
    <script src="../../../js/main.js"></script>
    <script src="../../../js/theme.js"></script>
    <script src="../../../js/language.js"></script>
    <script src="../../../js/blog-post.js"></script>
</body>
</html> 