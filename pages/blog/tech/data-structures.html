<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>数据结构：链表、栈、队列、串 - HealthJian的博客</title>
    <!-- 根据实际路径调整CSS引用路径 -->
    <link rel="stylesheet" href="../../../css/style.css">
    <link rel="stylesheet" href="../../../css/dark-mode.css">
    <link rel="stylesheet" href="../../../css/blog-post.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css">
    <link href="https://fonts.googleapis.com/css2?family=SF+Pro+Display:wght@300;400;500;600&display=swap" rel="stylesheet">
</head>
<body class="light-mode">
    <!-- 导航栏 -->
    <nav class="navbar">
        <div class="nav-left">
            <!-- 根据实际部署的文件夹深度调整路径 -->
            <a href="../../../index.html" class="logo">
                <img src="../../../images/githubherofigureimage.png" alt="Logo">
                <span class="site-name" data-en="HealthJian Blog" data-zh="HealthJian">HealthJian</span>
            </a>
        </div>
        <div class="nav-right">
            <ul class="menu">
                <!-- 根据实际部署的文件夹深度调整路径 -->
                <li><a href="../../../index.html" data-en="Home" data-zh="首页">首页</a></li>
                <li><a href="../../../blog.html" data-en="Blog" data-zh="博客">博客</a></li>
                <li><a href="https://github.com/CaiNiaojian" target="_blank" data-en="GitHub" data-zh="GitHub">GitHub</a></li>
                <li><a href="../../../links.html" data-en="Links" data-zh="链接">链接</a></li>
                <li><a href="../../../about.html" data-en="About" data-zh="关于">关于</a></li>
            </ul>
            <div class="social-icons">
                <a href="https://steamcommunity.com/id/yoursteamid" target="_blank" title="Steam"><i class="fab fa-steam"></i></a>
                <a href="mailto:gaojian1573@foxmail.com" title="Email"><i class="fas fa-envelope"></i></a>
            </div>
            <button id="theme-toggle" class="theme-toggle" title="切换主题">
                <i class="fas fa-moon"></i>
                <i class="fas fa-sun"></i>
            </button>
            <button id="lang-toggle" class="lang-toggle" title="切换语言">
                <span data-en="EN" data-zh="中">中</span>
            </button>
        </div>
    </nav>

    <div class="blog-post-container">
        <!-- 侧边栏 -->
        <aside class="blog-sidebar">
            <div class="toc-container">
                <h3 data-en="Table of Contents" data-zh="目录">目录</h3>
                <ul class="toc-list">
                    <!-- 文章目录，根据实际内容添加或修改 -->
                    <li><a href="#section-1" data-en="I. Introduction" data-zh="一、引言">一、引言</a></li>
                    <li><a href="#section-2" data-en="II. List" data-zh="二、链表">二、链表</a></li>
                    <li><a href="#section-3" data-en="III. Stack" data-zh="三、栈">三、栈</a></li>
                    <li><a href="#section-4" data-en="IV. Queue" data-zh="四、队列">四、队列</a></li>
                    <li><a href="#section-5" data-en="V. String" data-zh="五、串">五、串</a></li>
                    <!-- 根据需要添加更多章节 -->
                </ul>
            </div>
            
            <div class="post-meta-info">
                <div class="post-date">
                    <i class="far fa-calendar-alt"></i>
                    <span>2025-03-22</span> <!-- 更新实际发布日期 -->
                </div>
                <div class="post-tags">
                    <i class="fas fa-tags"></i>
                    <!-- 根据文章主题修改标签 -->
                    <span class="tag" data-en="data-structure" data-zh="数据结构">数据结构</span>
                    <span class="tag" data-en="basic-knowledge" data-zh="基础知识">基础知识</span>
                    <span class="tag" data-en="note" data-zh="笔记">笔记</span>
                </div>
                <div class="post-category">
                    <i class="fas fa-folder"></i>
                    <!-- 修改为实际分类 -->
                    <span data-en="tech" data-zh="技术">技术</span>
                </div>
            </div>
            
            <div class="post-navigation">
                <h3 data-en="Navigation" data-zh="导航">导航</h3>
                <div class="nav-buttons">
                    <a href="../blog.html" class="nav-button" data-en="Back to Blog" data-zh="返回博客列表">
                        <i class="fas fa-arrow-left"></i>
                        <span data-en="Back to Blog" data-zh="返回博客列表">返回博客列表</span>
                    </a>
                </div>
            </div>
        </aside>

        <!-- 文章主体 -->
        <main class="blog-post-main">
            <article class="blog-post-content">
                <header class="post-header">
                    <h1 class="post-title">
                        <div class="bilingual-content">
                            <span class="zh-content">数据结构：链表、栈、队列、串</span>
                            <span class="en-content" style="display: none;">Data Structures: Linked List, Stack, Queue, String</span>
                        </div>
                    </h1>
                </header>
                
                <div class="post-body">
                    <!-- 第一部分：引言 -->
                    <section id="section-1">
                        <h2 data-en="I. Introduction" data-zh="一、引言">一、引言</h2>
                        
                        <div class="bilingual-content">
                            <p class="zh-content">数据结构是计算机存储与组织数据的逻辑框架，为算法设计奠定基础。在学习数据结构的过程中，链表、栈、队列、串是必学的。这部分是循序渐进，由浅入深的过程。后者是表的扩展和对特定应用对象产生的技术，本质是表的抽象。</p>
                            
                            <p class="en-content" style="display: none;">Data structures provide logical frameworks for storing and organizing data, forming the foundation of algorithm design.Chained lists, stacks, queues, and strings are mandatory in learning data structures. This part is a gradual, step-by-step process. The latter is an extension of the table and the technology generated for specific application objects, the essence is the abstraction of the table.</p>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content">链表通过节点指针实现动态内存分配，支持高效的插入与删除操作。栈遵循后进先出原则，在函数调用和表达式求值中发挥关键作用。队列采用先进先出机制，广泛应用于任务调度和缓冲管理。串作为特殊线性结构，其模式匹配算法深刻影响着文本处理领域。这些基础结构共同构建了复杂算法的实现基石。😀</p>
                            
                            <p class="en-content" style="display: none;">Linked lists utilize node pointers for dynamic memory allocation, enabling efficient insertion and deletion operations.Stacks follow the Last-In-First-Out principle, playing vital roles in function calls and expression evaluation.Queues employ the First-In-First-Out mechanism, widely applied in task scheduling and buffer manag. Strings, as specialized linear structures, significantly influence text processing through pattern matching algorithms.ement.These fundamental structures collectively form the cornerstone for implementing complex algorithms.😀</p>
                        </div>

                        <div class="post-image">
                            <img src="../../../images/bluesky.avif" alt="天空" class="responsive-image">
                            <figcaption data-en="The sky" data-zh="天空">天空 <span class="emoji">🌙</span></figcaption>
                        </div>

                        <div class="bilingual-content">
                            <p class="zh-content">下文我将结合我最近学习的经验，以及应试角度的想法进行分享。🌹</p>
                            
                            <p class="en-content" style="display: none;">Below I will share my thoughts on my recent study experience, as well as my thoughts from a test-taking perspective.🌹</p>
                        </div>
                    </section>
                    
                    <!-- 第二部分 -->
                    <section id="section-2">
                        <h2 data-en="II. Linear List and Linked List" data-zh="二、线性表与链表">二、线性表与链表</h2>
                        
                        <h3 data-en="2.1 Sequential List" data-zh="2.1 顺序表">2.1 顺序表</h3>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>顺序表概念</strong><br>
                            顺序表是线性表的一种实现方式，它使用一段连续的内存空间存储线性表中的元素。在计算机中，通常使用数组来实现顺序表。顺序表的特点是支持随机访问，即可以在O(1)时间内访问任意位置的元素。</p>
                            
                            <p class="en-content" style="display: none;"><strong>Sequential List Concept</strong><br>
                            A sequential list is an implementation of a linear list that uses a contiguous memory space to store elements. In computers, arrays are typically used to implement sequential lists. The characteristic of sequential lists is that they support random access, meaning any element can be accessed in O(1) time.</p>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>顺序表的基本操作及时间复杂度</strong><br>
                            • 查找：O(1)，可以直接通过索引访问<br>
                            <div class="code-block">
<pre><code class="language-c">// C语言实现查找操作
int findElement(int arr[], int size, int index) {
    if(index >= 0 && index < size)
        return arr[index];  // O(1)时间复杂度
    return -1;  // 索引无效
}</code></pre>
                            </div><br>
                            • 插入：平均O(n)，需要移动插入位置后的所有元素<br>
                            <div class="code-block">
<pre><code class="language-c">// C语言实现插入操作
void insertElement(int arr[], int size, int pos, int value) {
    // 检查是否有足够空间和位置是否有效
    if (pos < 0 || pos > size) return;
    
    // 从最后一个元素开始向后移动
    for(int i = size; i > pos; i--) {
        arr[i] = arr[i-1];  // 元素后移
    }
    arr[pos] = value;  // 插入新元素
}</code></pre>
                            </div><br>
                            • 删除：平均O(n)，需要移动删除位置后的所有元素<br>
                            <div class="code-block">
<pre><code class="language-c">// C语言实现删除操作
void deleteElement(int arr[], int* size, int pos) {
    // 检查位置是否有效
    if (pos < 0 || pos >= *size) return;
    
    // 将删除位置后的元素前移
    for(int i = pos; i < *size - 1; i++) {
        arr[i] = arr[i+1];
    }
    (*size)--;  // 减小数组大小
}</code></pre>
                            </div><br>
                            • 修改：O(1)，直接通过索引修改<br>
                            <div class="code-block">
<pre><code class="language-c">// C语言实现修改操作
void modifyElement(int arr[], int size, int index, int newValue) {
    if(index >= 0 && index < size)
        arr[index] = newValue;  // O(1)时间复杂度
}</code></pre>
                            </div></p>
                            
                            <p class="en-content" style="display: none;"><strong>Basic Operations and Time Complexity of Sequential Lists</strong><br>
                            • Search: O(1), direct access through index<br>
                            • Insert: Average O(n), requires moving all elements after the insertion position<br>
                            • Delete: Average O(n), requires moving all elements after the deletion position<br>
                            • Modify: O(1), direct modification through index</p>
                        </div>
                        
                        <h3 data-en="2.2 Linked List Introduction" data-zh="2.2 链表引入">2.2 链表引入</h3>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>从顺序表到链表</strong><br>
                            顺序表虽然支持快速的随机访问，但在插入和删除操作时效率较低。链表通过使用不连续的内存空间，每个节点包含数据域和指针域，解决了顺序表的这一缺点。链表中的节点通过指针相互连接，形成一个线性结构。</p>
                            
                            <p class="en-content" style="display: none;"><strong>From Sequential List to Linked List</strong><br>
                            Although sequential lists support fast random access, they are inefficient for insertion and deletion operations. Linked lists solve this disadvantage by using non-contiguous memory spaces, with each node containing a data field and a pointer field. Nodes in a linked list are connected through pointers, forming a linear structure.</p>
                        </div>
                        
                        <h3 data-en="2.3 Singly Linked List" data-zh="2.3 单向链表">2.3 单向链表</h3>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>单向链表的结构</strong><br>
                            单向链表中的每个节点包含两部分：数据域和指针域。指针域存储指向下一个节点的指针。链表通常有一个头指针，指向链表的第一个节点。最后一个节点的指针域为空（NULL），表示链表结束。</p>
                            
                            <p class="en-content" style="display: none;"><strong>Structure of Singly Linked List</strong><br>
                            Each node in a singly linked list contains two parts: a data field and a pointer field. The pointer field stores a pointer to the next node. A linked list typically has a head pointer pointing to the first node. The pointer field of the last node is NULL, indicating the end of the list.</p>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>单向链表的基本操作及时间复杂度</strong><br>
                            • 查找：O(n)，需要从头节点开始遍历<br>
                            <div class="code-block">
<pre><code class="language-c">// C语言实现查找操作
Node* findElement(Node* head, int value) {
    Node* current = head;
    while (current != NULL) {
        if (current->data == value)
            return current;
        current = current->next;
    }
    return NULL;  // 未找到
}</code></pre>
                            </div><br>
                            • 插入：O(1)，如果已知插入位置的前一个节点<br>
                            <div class="code-block">
<pre><code class="language-c">// C语言实现插入操作
void insertAfter(Node* prevNode, int newValue) {
    if (prevNode == NULL) return;
    
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = newValue;
    newNode->next = prevNode->next;
    prevNode->next = newNode;
}</code></pre>
                            </div><br>
                            • 删除：O(1)，如果已知删除位置的前一个节点<br>
                            <div class="code-block">
<pre><code class="language-c">// C语言实现删除操作
void deleteAfter(Node* prevNode) {
    if (prevNode == NULL || prevNode->next == NULL)
        return;
    
    Node* toDelete = prevNode->next;
    prevNode->next = toDelete->next;
    free(toDelete);
}</code></pre>
                            </div><br>
                            • 修改：O(n)，需要先查找到节点<br>
                            <div class="code-block">
<pre><code class="language-c">// C语言实现修改操作
int modifyElement(Node* head, int oldValue, int newValue) {
    Node* current = head;
    while (current != NULL) {
        if (current->data == oldValue) {
            current->data = newValue;
            return 1;
        }
        current = current->next;
    }
    return 0;  // 未找到要修改的元素
}</code></pre>
                            </div></p>
                            
                            <p class="en-content" style="display: none;"><strong>Basic Operations and Time Complexity of Singly Linked Lists</strong><br>
                            • Search: O(n), requires traversal from the head node<br>
                            • Insert: O(1), if the previous node of the insertion position is known<br>
                            • Delete: O(1), if the previous node of the deletion position is known<br>
                            • Modify: O(n), requires finding the node first</p>
                        </div>
                        
                        <h3 data-en="2.4 Doubly Linked List" data-zh="2.4 双向链表">2.4 双向链表</h3>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>双向链表的结构</strong><br>
                            双向链表中的每个节点包含三部分：数据域、前驱指针和后继指针。前驱指针指向前一个节点，后继指针指向后一个节点。双向链表可以从两个方向遍历，增加了灵活性。</p>
                            
                            <p class="en-content" style="display: none;"><strong>Structure of Doubly Linked List</strong><br>
                            Each node in a doubly linked list contains three parts: a data field, a previous pointer, and a next pointer. The previous pointer points to the previous node, and the next pointer points to the next node. Doubly linked lists can be traversed in both directions, adding flexibility.</p>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>双向链表的基本操作及时间复杂度</strong><br>
                            • 查找：O(n)，可以从头或尾开始遍历<br>
                            <div class="code-block">
<pre><code class="language-c">// C语言实现双向链表查找操作
Node* search(Node* head, int value) {
    Node* current = head;
    while (current != NULL) {
        if (current->data == value)
            return current;
        current = current->next;
    }
    return NULL;  // 未找到元素
}</code></pre>
                            </div><br>
                            • 插入：O(1)，如果已知插入位置的节点<br>
                            <div class="code-block">
<pre><code class="language-c">// C语言实现双向链表插入操作
void insertAfter(Node* node, int value) {
    if (node == NULL) return;
    
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = value;
    
    newNode->next = node->next;
    newNode->prev = node;
    
    if (node->next != NULL)
        node->next->prev = newNode;
        
    node->next = newNode;
}</code></pre>
                            </div><br>
                            • 删除：O(1)，如果已知删除位置的节点<br>
                            <div class="code-block">
<pre><code class="language-c">// C语言实现双向链表删除操作
void deleteNode(Node* node) {
    if (node == NULL) return;
    
    if (node->prev != NULL)
        node->prev->next = node->next;
        
    if (node->next != NULL)
        node->next->prev = node->prev;
        
    free(node);
}</code></pre>
                            </div><br>
                            • 修改：O(n)，需要先查找到节点<br>
                            <div class="code-block">
<pre><code class="language-c">// C语言实现双向链表修改操作
int modifyElement(Node* head, int oldValue, int newValue) {
    Node* node = search(head, oldValue);
    if (node != NULL) {
        node->data = newValue;
        return 1;
    }
    return 0;  // 未找到要修改的元素
}</code></pre>
                            </div></p>
                            
                            <p class="en-content" style="display: none;"><strong>Basic Operations and Time Complexity of Doubly Linked Lists</strong><br>
                            • Search: O(n), can traverse from either head or tail<br>
                            • Insert: O(1), if the node at the insertion position is known<br>
                            • Delete: O(1), if the node at the deletion position is known<br>
                            • Modify: O(n), requires finding the node first</p>
                        </div>
                        
                        <h3 data-en="2.5 Common Algorithm Problems" data-zh="2.5 常见算法题型">2.5 常见算法题型</h3>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>1. 有序链表合并</strong><br>
                            将两个已排序的链表合并为一个新的有序链表。这是一个常见的基础算法问题，也是归并排序的核心操作。</p>
                            
                            <p class="en-content" style="display: none;"><strong>1. Merge Two Sorted Lists</strong><br>
                            Merge two sorted linked lists into a new sorted list. This is a common fundamental algorithm problem and also the core operation of merge sort.</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// 合并两个有序链表（C语言）
struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) {
    struct ListNode dummy;
    struct ListNode* tail = &dummy;
    
    while (l1 && l2) {
        if (l1->val < l2->val) {
            tail->next = l1;
            l1 = l1->next;
        } else {
            tail->next = l2;
            l2 = l2->next;
        }
        tail = tail->next;
    }
    
    tail->next = l1 ? l1 : l2;
    return dummy.next;
}</code></pre>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>2. 链表集合操作 - 交集</strong><br>
                            给定两个链表，求它们的交集（即在两个链表中都出现的元素）。通常假设链表中无重复元素。</p>
                            
                            <p class="en-content" style="display: none;"><strong>2. Linked List Set Operations - Intersection</strong><br>
                            Given two linked lists, find their intersection (elements that appear in both lists). Usually assumes no duplicate elements in the lists.</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// 求两个链表的交集（C语言）
struct ListNode* getIntersection(struct ListNode* headA, struct ListNode* headB) {
    // 使用哈希表存储第一个链表的值
    int hash[10000] = {0}; // 假设值的范围在0-9999之间
    struct ListNode dummy;
    struct ListNode* tail = &dummy;
    dummy.next = NULL;
    
    // 将第一个链表的所有值标记在哈希表中
    while (headA) {
        hash[headA->val] = 1;
        headA = headA->next;
    }
    
    // 检查第二个链表中的值是否在哈希表中
    while (headB) {
        if (hash[headB->val] == 1) {
            struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));
            newNode->val = headB->val;
            newNode->next = NULL;
            
            tail->next = newNode;
            tail = tail->next;
            hash[headB->val] = 0; // 防止重复添加
        }
        headB = headB->next;
    }
    
    return dummy.next;
}</code></pre>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>3. 链表集合操作 - 并集</strong><br>
                            给定两个链表，求它们的并集（即包含两个链表中所有不重复的元素）。</p>
                            
                            <p class="en-content" style="display: none;"><strong>3. Linked List Set Operations - Union</strong><br>
                            Given two linked lists, find their union (all unique elements from both lists).</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// 求两个链表的并集（C语言）
struct ListNode* getUnion(struct ListNode* headA, struct ListNode* headB) {
    int hash[10000] = {0}; // 假设值的范围在0-9999之间
    struct ListNode dummy;
    struct ListNode* tail = &dummy;
    dummy.next = NULL;
    
    // 处理第一个链表
    while (headA) {
        if (hash[headA->val] == 0) {
            hash[headA->val] = 1;
            
            struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));
            newNode->val = headA->val;
            newNode->next = NULL;
            
            tail->next = newNode;
            tail = tail->next;
        }
        headA = headA->next;
    }
    
    // 处理第二个链表
    while (headB) {
        if (hash[headB->val] == 0) {
            hash[headB->val] = 1;
            
            struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));
            newNode->val = headB->val;
            newNode->next = NULL;
            
            tail->next = newNode;
            tail = tail->next;
        }
        headB = headB->next;
    }
    
    return dummy.next;
}</code></pre>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>4. 链表集合操作 - 补集</strong><br>
                            给定两个链表A和B，求A相对于B的补集（即在A中出现但不在B中出现的元素）。</p>
                            
                            <p class="en-content" style="display: none;"><strong>4. Linked List Set Operations - Complement</strong><br>
                            Given two linked lists A and B, find the complement of A with respect to B (elements that appear in A but not in B).</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// 求链表A相对于B的补集（C语言）
struct ListNode* getComplement(struct ListNode* headA, struct ListNode* headB) {
    int hash[10000] = {0}; // 假设值的范围在0-9999之间
    struct ListNode dummy;
    struct ListNode* tail = &dummy;
    dummy.next = NULL;
    
    // 将B中所有元素标记在哈希表中
    while (headB) {
        hash[headB->val] = 1;
        headB = headB->next;
    }
    
    // 检查A中的元素是否不在B中
    while (headA) {
        if (hash[headA->val] == 0) {
            struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));
            newNode->val = headA->val;
            newNode->next = NULL;
            
            tail->next = newNode;
            tail = tail->next;
        }
        headA = headA->next;
    }
    
    return dummy.next;
}</code></pre>
                        </div>
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>5. 链表反转</strong><br>
                            将一个单向链表反转，使所有节点的指向反向。这是面试中的经典问题。</p>
                            
                            <p class="en-content" style="display: none;"><strong>5. Linked List Reversal</strong><br>
                            Reverse a singly linked list, changing the direction of all node pointers. This is a classic interview problem.</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// 链表反转代码示例（C语言）
struct ListNode* reverseList(struct ListNode* head) {
    struct ListNode* prev = NULL;
    struct ListNode* curr = head;
    while (curr != NULL) {
        struct ListNode* next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}</code></pre>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>6. 检测环形链表</strong><br>
                            判断一个链表是否包含环。可以使用快慢指针（Floyd's Cycle-Finding Algorithm）解决。</p>
                            
                            <p class="en-content" style="display: none;"><strong>6. Detecting Cycle in a Linked List</strong><br>
                            Determine if a linked list contains a cycle. This can be solved using the fast and slow pointer technique (Floyd's Cycle-Finding Algorithm).</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// 检测环形链表代码示例（C语言）
bool hasCycle(struct ListNode* head) {
    if (head == NULL || head->next == NULL) return false;
    
    struct ListNode* slow = head;
    struct ListNode* fast = head;
    
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) return true;
    }
    
    return false;
}</code></pre>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>7. 找出链表的中间节点</strong><br>
                            找出单向链表的中间节点。同样可以使用快慢指针解决。</p>
                            
                            <p class="en-content" style="display: none;"><strong>7. Finding the Middle Node of a Linked List</strong><br>
                            Find the middle node of a singly linked list. This can also be solved using the fast and slow pointer technique.</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// 找出链表中间节点代码示例（C语言）
struct ListNode* middleNode(struct ListNode* head) {
    struct ListNode* slow = head;
    struct ListNode* fast = head;
    
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
    }
    
    return slow;
}</code></pre>
                        </div>
                        
                        <!-- 代码示例（如果需要） -->
                        <div class="code-block">
                            <pre><code class="language-c">// 此处添加代码示例
void example() {
    printf("Hello, World!\n");
}</code></pre>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>示例分析</strong><br>
                            分析上述代码或概念的应用示例：</p>
                            
                            <p class="en-content" style="display: none;"><strong>Example Analysis</strong><br>
                            Analyze the application examples of the above code or concepts:</p>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>总结</strong><br>
                            小节内容总结 <span class="emoji">📝</span></p>
                            
                            <p class="en-content" style="display: none;"><strong>Summary</strong><br>
                            Summary of the subsection content <span class="emoji">📝</span></p>
                        </div>
                        
                        <h3 data-en="2.2 Subsection Two" data-zh="2.2 小节二">2.2 小节二</h3>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>概念解释</strong><br>
                            在此处解释相关概念</p>
                            
                            <p class="en-content" style="display: none;"><strong>Concept Explanation</strong><br>
                            Explain related concepts here</p>
                        </div>
                        
                        <!-- 图片示例（如果需要）--> 
                        <div class="post-image">
                            <img src="../../images/example.jpg" alt="示例图片" class="responsive-image">
                            <figcaption data-en="Example Image" data-zh="示例图片">示例图片</figcaption>
                        </div>
                    </section>
                    
                    <!-- 第三部分 -->
                    <section id="section-3">
                        <h2 data-en="III. Section Three" data-zh="三、第三部分">三、第三部分</h2>
                        
                        <div class="bilingual-content">
                            <p class="zh-content">此处添加第三部分的内容。可以包含段落、列表、代码示例等。</p>
                            
                            <p class="en-content" style="display: none;">Add content for section three here. Can include paragraphs, lists, code examples, etc.</p>
                        </div>
                        
                        <!-- 列表示例 -->
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>要点列表：</strong></p>
                            <ul class="zh-content">
                                <li>第一个要点</li>
                                <li>第二个要点</li>
                                <li>第三个要点</li>
                            </ul>
                            
                            <p class="en-content" style="display: none;"><strong>Key Points:</strong></p>
                            <ul class="en-content" style="display: none;">
                                <li>First point</li>
                                <li>Second point</li>
                                <li>Third point</li>
                            </ul>
                        </div>
                    </section>
                    
                    <!-- 结语 -->
                    <div class="post-conclusion">
                        <h2 data-en="Conclusion" data-zh="结语">结语</h2>
                        
                        <div class="bilingual-content">
                            <p class="zh-content">总结文章的主要观点和结论。提供进一步思考或后续学习的建议。</p>
                            
                            <p class="en-content" style="display: none;">Summarize the main points and conclusions of the article. Provide suggestions for further thinking or subsequent learning.</p>
                            
                            <p class="zh-content">感谢阅读！如有问题或建议，欢迎在评论区留言。 <span class="emoji">💻✨</span></p>
                            
                            <p class="en-content" style="display: none;">Thanks for reading! If you have any questions or suggestions, please leave a message in the comments section. <span class="emoji">💻✨</span></p>
                        </div>
                        
                        <div class="post-signature">
                            <p>— HealthJian <span class="emoji">✍️</span></p>
                        </div>
                    </div>
                </div>
            </article>
            
            <!-- 评论区 -->
            <div class="comments-section">
                <h3 data-en="Comments" data-zh="评论">评论</h3>
                <div class="comment-form">
                    <textarea placeholder="写下你的想法..." data-en-placeholder="Write your thoughts..." data-zh-placeholder="写下你的想法..."></textarea>
                    <button data-en="Submit" data-zh="提交">提交</button>
                </div>
                <div class="comments-container">
                    <p class="no-comments" data-en="Be the first to comment!" data-zh="成为第一个评论的人！">成为第一个评论的人！ <span class="emoji">🎉</span></p>
                </div>
            </div>
        </main>
    </div>

    <!-- 页脚 -->
    <footer>
        <div class="footer-content">
            <div class="footer-info">
                <p>&copy; 2025 CaiNiaojian&HealthJian all followed.</p>
                <p data-en="Contact: " data-zh="联系方式：">联系方式：<a href="mailto:gaojian1573@foxmail.com">gaojian1573@foxmail.com</a></p>
                <p data-en="Location: " data-zh="地址：">地址：XX</p>
            </div>
            <div class="footer-links">
                <a href="../../../blog.html" data-en="Blog" data-zh="博客">博客</a>
                <a href="../../../about.html" data-en="About" data-zh="关于">关于</a>
                <a href="https://github.com/CaiNiaojian" target="_blank" data-en="GitHub" data-zh="GitHub">GitHub</a>
                <a href="../../../changelog.html" data-en="ChangeLog" data-zh="更新日志">更新日志</a>
            </div>
        </div>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // 初始化代码高亮
            hljs.highlightAll();
        });
    </script>
    <script src="../../../js/main.js"></script>
    <script src="../../../js/theme.js"></script>
    <script src="../../../js/language.js"></script>
    <script src="../../../js/blog-post.js"></script>
</body>
</html> 