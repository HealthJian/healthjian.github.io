<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="../../../images/favicon.ico" />
    <title>æ•°æ®ç»“æ„ï¼šé“¾è¡¨ã€æ ˆã€é˜Ÿåˆ—ã€ä¸² - HealthJiançš„åšå®¢</title>
    <!-- æ ¹æ®å®é™…è·¯å¾„è°ƒæ•´CSSå¼•ç”¨è·¯å¾„ -->
    <link rel="stylesheet" href="../../../css/style.css">
    <link rel="stylesheet" href="../../../css/dark-mode.css">
    <link rel="stylesheet" href="../../../css/blog-post.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css">
    <link href="https://fonts.googleapis.com/css2?family=SF+Pro+Display:wght@300;400;500;600&display=swap" rel="stylesheet">
</head>
<body class="light-mode">
    <!-- å¯¼èˆªæ  -->
    <nav class="navbar">
        <div class="nav-left">
            <!-- æ ¹æ®å®é™…éƒ¨ç½²çš„æ–‡ä»¶å¤¹æ·±åº¦è°ƒæ•´è·¯å¾„ -->
            <a href="../../../index.html" class="logo">
                <img src="../../../images/githubherofigureimage.png" alt="Logo">
                <span class="site-name" data-en="HealthJian Blog" data-zh="HealthJian">HealthJian</span>
            </a>
        </div>
        <div class="nav-right">
            <ul class="menu">
                <!-- æ ¹æ®å®é™…éƒ¨ç½²çš„æ–‡ä»¶å¤¹æ·±åº¦è°ƒæ•´è·¯å¾„ -->
                <li><a href="../../../index.html" data-en="Home" data-zh="é¦–é¡µ">é¦–é¡µ</a></li>
                <li><a href="../../../blog.html" data-en="Blog" data-zh="åšå®¢">åšå®¢</a></li>
                <li><a href="https://github.com/CaiNiaojian" target="_blank" data-en="GitHub" data-zh="GitHub">GitHub</a></li>
                <li><a href="../../../links.html" data-en="Links" data-zh="é“¾æ¥">é“¾æ¥</a></li>
                <li><a href="../../../about.html" data-en="About" data-zh="å…³äº">å…³äº</a></li>
            </ul>
            <div class="social-icons">
                <a href="https://steamcommunity.com/id/yoursteamid" target="_blank" title="Steam"><i class="fab fa-steam"></i></a>
                <a href="mailto:gaojian1573@foxmail.com" title="Email"><i class="fas fa-envelope"></i></a>
            </div>
            <button id="theme-toggle" class="theme-toggle" title="åˆ‡æ¢ä¸»é¢˜">
                <i class="fas fa-moon"></i>
                <i class="fas fa-sun"></i>
            </button>
            <button id="lang-toggle" class="lang-toggle" title="åˆ‡æ¢è¯­è¨€">
                <span data-en="EN" data-zh="ä¸­">ä¸­</span>
            </button>
        </div>
    </nav>

    <div class="blog-post-container">
        <!-- ä¾§è¾¹æ  -->
        <aside class="blog-sidebar">
            <div class="toc-container">
                <h3 data-en="Table of Contents" data-zh="ç›®å½•">ç›®å½•</h3>
                <ul class="toc-list">
                    <!-- æ–‡ç« ç›®å½•ï¼Œæ ¹æ®å®é™…å†…å®¹æ·»åŠ æˆ–ä¿®æ”¹ -->
                    <li><a href="#section-1" data-en="I. Introduction" data-zh="ä¸€ã€å¼•è¨€">ä¸€ã€å¼•è¨€</a></li>
                    <li><a href="#section-2" data-en="II. List" data-zh="äºŒã€é“¾è¡¨">äºŒã€é“¾è¡¨</a></li>
                    <li><a href="#section-3" data-en="III. Stack" data-zh="ä¸‰ã€æ ˆ">ä¸‰ã€æ ˆ</a></li>
                    <li><a href="#section-4" data-en="IV. Queue" data-zh="å››ã€é˜Ÿåˆ—">å››ã€é˜Ÿåˆ—</a></li>
                    <li><a href="#section-5" data-en="V. String" data-zh="äº”ã€ä¸²">äº”ã€ä¸²</a></li>
                    <!-- æ ¹æ®éœ€è¦æ·»åŠ æ›´å¤šç« èŠ‚ -->
                </ul>
            </div>
            
            <div class="post-meta-info">
                <div class="post-date">
                    <i class="far fa-calendar-alt"></i>
                    <span>2025-03-22</span> <!-- æ›´æ–°åˆæ¬¡å‘å¸ƒæ—¥æœŸ -->
                </div>
                <div class="post-date">
                    <i class="far fa-calendar-alt"></i>
                    <span>2025-03-24</span> <!-- æ›´æ–°å®é™…å‘å¸ƒæ—¥æœŸ -->
                </div>
                <div class="post-tags">
                    <i class="fas fa-tags"></i>
                    <!-- æ ¹æ®æ–‡ç« ä¸»é¢˜ä¿®æ”¹æ ‡ç­¾ -->
                    <span class="tag" data-en="data-structure" data-zh="æ•°æ®ç»“æ„">æ•°æ®ç»“æ„</span>
                    <span class="tag" data-en="basic-knowledge" data-zh="åŸºç¡€çŸ¥è¯†">åŸºç¡€çŸ¥è¯†</span>
                    <span class="tag" data-en="note" data-zh="ç¬”è®°">ç¬”è®°</span>
                </div>
                <div class="post-category">
                    <i class="fas fa-folder"></i>
                    <!-- ä¿®æ”¹ä¸ºå®é™…åˆ†ç±» -->
                    <span data-en="tech" data-zh="æŠ€æœ¯">æŠ€æœ¯</span>
                </div>
            </div>
            
            <div class="post-navigation">
                <h3 data-en="Navigation" data-zh="å¯¼èˆª">å¯¼èˆª</h3>
                <div class="nav-buttons">
                    <a href="../blog.html" class="nav-button" data-en="Back to Blog" data-zh="è¿”å›åšå®¢åˆ—è¡¨">
                        <i class="fas fa-arrow-left"></i>
                        <span data-en="Back to Blog" data-zh="è¿”å›åšå®¢åˆ—è¡¨">è¿”å›åšå®¢åˆ—è¡¨</span>
                    </a>
                </div>
            </div>
        </aside>

        <!-- æ–‡ç« ä¸»ä½“ -->
        <main class="blog-post-main">
            <article class="blog-post-content">
                <header class="post-header">
                    <h1 class="post-title">
                        <div class="bilingual-content">
                            <span class="zh-content">æ•°æ®ç»“æ„ï¼šé“¾è¡¨ã€æ ˆã€é˜Ÿåˆ—ã€ä¸²</span>
                            <span class="en-content" style="display: none;">Data Structures: Linked List, Stack, Queue, String</span>
                        </div>
                    </h1>
                </header>
                
                <div class="post-body">
                    <!-- ç¬¬ä¸€éƒ¨åˆ†ï¼šå¼•è¨€ -->
                    <section id="section-1">
                        <h2 data-en="I. Introduction" data-zh="ä¸€ã€å¼•è¨€">ä¸€ã€å¼•è¨€</h2>
                        
                        <div class="bilingual-content">
                            <p class="zh-content">æ•°æ®ç»“æ„æ˜¯è®¡ç®—æœºå­˜å‚¨ä¸ç»„ç»‡æ•°æ®çš„é€»è¾‘æ¡†æ¶ï¼Œä¸ºç®—æ³•è®¾è®¡å¥ å®šåŸºç¡€ã€‚åœ¨å­¦ä¹ æ•°æ®ç»“æ„çš„è¿‡ç¨‹ä¸­ï¼Œé“¾è¡¨ã€æ ˆã€é˜Ÿåˆ—ã€ä¸²æ˜¯å¿…å­¦çš„ã€‚è¿™éƒ¨åˆ†æ˜¯å¾ªåºæ¸è¿›ï¼Œç”±æµ…å…¥æ·±çš„è¿‡ç¨‹ã€‚åè€…æ˜¯è¡¨çš„æ‰©å±•å’Œå¯¹ç‰¹å®šåº”ç”¨å¯¹è±¡äº§ç”Ÿçš„æŠ€æœ¯ï¼Œæœ¬è´¨æ˜¯è¡¨çš„æŠ½è±¡ã€‚</p>
                            
                            <p class="en-content" style="display: none;">Data structures provide logical frameworks for storing and organizing data, forming the foundation of algorithm design.Chained lists, stacks, queues, and strings are mandatory in learning data structures. This part is a gradual, step-by-step process. The latter is an extension of the table and the technology generated for specific application objects, the essence is the abstraction of the table.</p>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content">é“¾è¡¨é€šè¿‡èŠ‚ç‚¹æŒ‡é’ˆå®ç°åŠ¨æ€å†…å­˜åˆ†é…ï¼Œæ”¯æŒé«˜æ•ˆçš„æ’å…¥ä¸åˆ é™¤æ“ä½œã€‚æ ˆéµå¾ªåè¿›å…ˆå‡ºåŸåˆ™ï¼Œåœ¨å‡½æ•°è°ƒç”¨å’Œè¡¨è¾¾å¼æ±‚å€¼ä¸­å‘æŒ¥å…³é”®ä½œç”¨ã€‚é˜Ÿåˆ—é‡‡ç”¨å…ˆè¿›å…ˆå‡ºæœºåˆ¶ï¼Œå¹¿æ³›åº”ç”¨äºä»»åŠ¡è°ƒåº¦å’Œç¼“å†²ç®¡ç†ã€‚ä¸²ä½œä¸ºç‰¹æ®Šçº¿æ€§ç»“æ„ï¼Œå…¶æ¨¡å¼åŒ¹é…ç®—æ³•æ·±åˆ»å½±å“ç€æ–‡æœ¬å¤„ç†é¢†åŸŸã€‚è¿™äº›åŸºç¡€ç»“æ„å…±åŒæ„å»ºäº†å¤æ‚ç®—æ³•çš„å®ç°åŸºçŸ³ã€‚ğŸ˜€</p>
                            
                            <p class="en-content" style="display: none;">Linked lists utilize node pointers for dynamic memory allocation, enabling efficient insertion and deletion operations.Stacks follow the Last-In-First-Out principle, playing vital roles in function calls and expression evaluation.Queues employ the First-In-First-Out mechanism, widely applied in task scheduling and buffer manag. Strings, as specialized linear structures, significantly influence text processing through pattern matching algorithms.ement.These fundamental structures collectively form the cornerstone for implementing complex algorithms.ğŸ˜€</p>
                        </div>

                        <div class="post-image">
                            <img src="../../../images/astronomy.avif" alt="å¤©ç©º" class="responsive-image">
                            <figcaption data-en="The sky" data-zh="å¤©ç©º">å¤©ç©º <span class="emoji">ğŸŒ™</span></figcaption>
                        </div>

                        <div class="bilingual-content">
                            <p class="zh-content">ä¸‹æ–‡æˆ‘å°†ç»“åˆæˆ‘æœ€è¿‘å­¦ä¹ çš„ç»éªŒï¼Œä»¥åŠåº”è¯•è§’åº¦çš„æƒ³æ³•è¿›è¡Œåˆ†äº«ã€‚ğŸŒ¹</p>
                            
                            <p class="en-content" style="display: none;">Below I will share my thoughts on my recent study experience, as well as my thoughts from a test-taking perspective.ğŸŒ¹</p>
                        </div>
                    </section>
                    
                    <!-- ç¬¬äºŒéƒ¨åˆ† -->
                    <section id="section-2">
                        <h2 data-en="II. Linear List and Linked List" data-zh="äºŒã€çº¿æ€§è¡¨ä¸é“¾è¡¨">äºŒã€çº¿æ€§è¡¨ä¸é“¾è¡¨</h2>
                        
                        <h3 data-en="2.1 Sequential List" data-zh="2.1 é¡ºåºè¡¨">2.1 é¡ºåºè¡¨</h3>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>é¡ºåºè¡¨æ¦‚å¿µ</strong><br>
                            é¡ºåºè¡¨æ˜¯çº¿æ€§è¡¨çš„ä¸€ç§å®ç°æ–¹å¼ï¼Œå®ƒä½¿ç”¨ä¸€æ®µè¿ç»­çš„å†…å­˜ç©ºé—´å­˜å‚¨çº¿æ€§è¡¨ä¸­çš„å…ƒç´ ã€‚åœ¨è®¡ç®—æœºä¸­ï¼Œé€šå¸¸ä½¿ç”¨æ•°ç»„æ¥å®ç°é¡ºåºè¡¨ã€‚é¡ºåºè¡¨çš„ç‰¹ç‚¹æ˜¯æ”¯æŒéšæœºè®¿é—®ï¼Œå³å¯ä»¥åœ¨O(1)æ—¶é—´å†…è®¿é—®ä»»æ„ä½ç½®çš„å…ƒç´ ã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>Sequential List Concept</strong><br>
                            A sequential list is an implementation of a linear list that uses a contiguous memory space to store elements. In computers, arrays are typically used to implement sequential lists. The characteristic of sequential lists is that they support random access, meaning any element can be accessed in O(1) time.</p>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>é¡ºåºè¡¨çš„åŸºæœ¬æ“ä½œåŠæ—¶é—´å¤æ‚åº¦</strong><br>
                            â€¢ æŸ¥æ‰¾ï¼šO(1)ï¼Œå¯ä»¥ç›´æ¥é€šè¿‡ç´¢å¼•è®¿é—®<br>
                            <div class="code-block">
<pre><code class="language-c">// Cè¯­è¨€å®ç°æŸ¥æ‰¾æ“ä½œ
int findElement(int arr[], int size, int index) {
    if(index >= 0 && index < size)
        return arr[index];  // O(1)æ—¶é—´å¤æ‚åº¦
    return -1;  // ç´¢å¼•æ— æ•ˆ
}</code></pre>
                            </div><br>
                            â€¢ æ’å…¥ï¼šå¹³å‡O(n)ï¼Œéœ€è¦ç§»åŠ¨æ’å…¥ä½ç½®åçš„æ‰€æœ‰å…ƒç´ <br>
                            <div class="code-block">
<pre><code class="language-c">// Cè¯­è¨€å®ç°æ’å…¥æ“ä½œ
void insertElement(int arr[], int size, int pos, int value) {
    // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿç©ºé—´å’Œä½ç½®æ˜¯å¦æœ‰æ•ˆ
    if (pos < 0 || pos > size) return;
    
    // ä»æœ€åä¸€ä¸ªå…ƒç´ å¼€å§‹å‘åç§»åŠ¨
    for(int i = size; i > pos; i--) {
        arr[i] = arr[i-1];  // å…ƒç´ åç§»
    }
    arr[pos] = value;  // æ’å…¥æ–°å…ƒç´ 
}</code></pre>
                            </div><br>
                            â€¢ åˆ é™¤ï¼šå¹³å‡O(n)ï¼Œéœ€è¦ç§»åŠ¨åˆ é™¤ä½ç½®åçš„æ‰€æœ‰å…ƒç´ <br>
                            <div class="code-block">
<pre><code class="language-c">// Cè¯­è¨€å®ç°åˆ é™¤æ“ä½œ
void deleteElement(int arr[], int* size, int pos) {
    // æ£€æŸ¥ä½ç½®æ˜¯å¦æœ‰æ•ˆ
    if (pos < 0 || pos >= *size) return;
    
    // å°†åˆ é™¤ä½ç½®åçš„å…ƒç´ å‰ç§»
    for(int i = pos; i < *size - 1; i++) {
        arr[i] = arr[i+1];
    }
    (*size)--;  // å‡å°æ•°ç»„å¤§å°
}</code></pre>
                            </div><br>
                            â€¢ ä¿®æ”¹ï¼šO(1)ï¼Œç›´æ¥é€šè¿‡ç´¢å¼•ä¿®æ”¹<br>
                            <div class="code-block">
<pre><code class="language-c">// Cè¯­è¨€å®ç°ä¿®æ”¹æ“ä½œ
void modifyElement(int arr[], int size, int index, int newValue) {
    if(index >= 0 && index < size)
        arr[index] = newValue;  // O(1)æ—¶é—´å¤æ‚åº¦
}</code></pre>
                            </div></p>
                            
                            <p class="en-content" style="display: none;"><strong>Basic Operations and Time Complexity of Sequential Lists</strong><br>
                            â€¢ Search: O(1), direct access through index<br>
                            â€¢ Insert: Average O(n), requires moving all elements after the insertion position<br>
                            â€¢ Delete: Average O(n), requires moving all elements after the deletion position<br>
                            â€¢ Modify: O(1), direct modification through index</p>
                        </div>
                        
                        <h3 data-en="2.2 Linked List Introduction" data-zh="2.2 é“¾è¡¨å¼•å…¥">2.2 é“¾è¡¨å¼•å…¥</h3>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>ä»é¡ºåºè¡¨åˆ°é“¾è¡¨</strong><br>
                            é¡ºåºè¡¨è™½ç„¶æ”¯æŒå¿«é€Ÿçš„éšæœºè®¿é—®ï¼Œä½†åœ¨æ’å…¥å’Œåˆ é™¤æ“ä½œæ—¶æ•ˆç‡è¾ƒä½ã€‚é“¾è¡¨é€šè¿‡ä½¿ç”¨ä¸è¿ç»­çš„å†…å­˜ç©ºé—´ï¼Œæ¯ä¸ªèŠ‚ç‚¹åŒ…å«æ•°æ®åŸŸå’ŒæŒ‡é’ˆåŸŸï¼Œè§£å†³äº†é¡ºåºè¡¨çš„è¿™ä¸€ç¼ºç‚¹ã€‚é“¾è¡¨ä¸­çš„èŠ‚ç‚¹é€šè¿‡æŒ‡é’ˆç›¸äº’è¿æ¥ï¼Œå½¢æˆä¸€ä¸ªçº¿æ€§ç»“æ„ã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>From Sequential List to Linked List</strong><br>
                            Although sequential lists support fast random access, they are inefficient for insertion and deletion operations. Linked lists solve this disadvantage by using non-contiguous memory spaces, with each node containing a data field and a pointer field. Nodes in a linked list are connected through pointers, forming a linear structure.</p>
                        </div>
                        
                        <h3 data-en="2.3 Singly Linked List" data-zh="2.3 å•å‘é“¾è¡¨">2.3 å•å‘é“¾è¡¨</h3>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>å•å‘é“¾è¡¨çš„ç»“æ„</strong><br>
                            å•å‘é“¾è¡¨ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹åŒ…å«ä¸¤éƒ¨åˆ†ï¼šæ•°æ®åŸŸå’ŒæŒ‡é’ˆåŸŸã€‚æŒ‡é’ˆåŸŸå­˜å‚¨æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆã€‚é“¾è¡¨é€šå¸¸æœ‰ä¸€ä¸ªå¤´æŒ‡é’ˆï¼ŒæŒ‡å‘é“¾è¡¨çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆåŸŸä¸ºç©ºï¼ˆNULLï¼‰ï¼Œè¡¨ç¤ºé“¾è¡¨ç»“æŸã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>Structure of Singly Linked List</strong><br>
                            Each node in a singly linked list contains two parts: a data field and a pointer field. The pointer field stores a pointer to the next node. A linked list typically has a head pointer pointing to the first node. The pointer field of the last node is NULL, indicating the end of the list.</p>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>å•å‘é“¾è¡¨çš„åŸºæœ¬æ“ä½œåŠæ—¶é—´å¤æ‚åº¦</strong><br>
                            â€¢ æŸ¥æ‰¾ï¼šO(n)ï¼Œéœ€è¦ä»å¤´èŠ‚ç‚¹å¼€å§‹éå†<br>
                            <div class="code-block">
<pre><code class="language-c">// Cè¯­è¨€å®ç°æŸ¥æ‰¾æ“ä½œ
Node* findElement(Node* head, int value) {
    Node* current = head;
    while (current != NULL) {
        if (current->data == value)
            return current;
        current = current->next;
    }
    return NULL;  // æœªæ‰¾åˆ°
}</code></pre>
                            </div><br>
                            â€¢ æ’å…¥ï¼šO(1)ï¼Œå¦‚æœå·²çŸ¥æ’å…¥ä½ç½®çš„å‰ä¸€ä¸ªèŠ‚ç‚¹<br>
                            <div class="code-block">
<pre><code class="language-c">// Cè¯­è¨€å®ç°æ’å…¥æ“ä½œ
void insertAfter(Node* prevNode, int newValue) {
    if (prevNode == NULL) return;
    
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = newValue;
    newNode->next = prevNode->next;
    prevNode->next = newNode;
}</code></pre>
                            </div><br>
                            â€¢ åˆ é™¤ï¼šO(1)ï¼Œå¦‚æœå·²çŸ¥åˆ é™¤ä½ç½®çš„å‰ä¸€ä¸ªèŠ‚ç‚¹<br>
                            <div class="code-block">
<pre><code class="language-c">// Cè¯­è¨€å®ç°åˆ é™¤æ“ä½œ
void deleteAfter(Node* prevNode) {
    if (prevNode == NULL || prevNode->next == NULL)
        return;
    
    Node* toDelete = prevNode->next;
    prevNode->next = toDelete->next;
    free(toDelete);
}</code></pre>
                            </div><br>
                            â€¢ ä¿®æ”¹ï¼šO(n)ï¼Œéœ€è¦å…ˆæŸ¥æ‰¾åˆ°èŠ‚ç‚¹<br>
                            <div class="code-block">
<pre><code class="language-c">// Cè¯­è¨€å®ç°ä¿®æ”¹æ“ä½œ
int modifyElement(Node* head, int oldValue, int newValue) {
    Node* current = head;
    while (current != NULL) {
        if (current->data == oldValue) {
            current->data = newValue;
            return 1;
        }
        current = current->next;
    }
    return 0;  // æœªæ‰¾åˆ°è¦ä¿®æ”¹çš„å…ƒç´ 
}</code></pre>
                            </div></p>
                            
                            <p class="en-content" style="display: none;"><strong>Basic Operations and Time Complexity of Singly Linked Lists</strong><br>
                            â€¢ Search: O(n), requires traversal from the head node<br>
                            â€¢ Insert: O(1), if the previous node of the insertion position is known<br>
                            â€¢ Delete: O(1), if the previous node of the deletion position is known<br>
                            â€¢ Modify: O(n), requires finding the node first</p>
                        </div>
                        
                        <h3 data-en="2.4 Doubly Linked List" data-zh="2.4 åŒå‘é“¾è¡¨">2.4 åŒå‘é“¾è¡¨</h3>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>åŒå‘é“¾è¡¨çš„ç»“æ„</strong><br>
                            åŒå‘é“¾è¡¨ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹åŒ…å«ä¸‰éƒ¨åˆ†ï¼šæ•°æ®åŸŸã€å‰é©±æŒ‡é’ˆå’Œåç»§æŒ‡é’ˆã€‚å‰é©±æŒ‡é’ˆæŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œåç»§æŒ‡é’ˆæŒ‡å‘åä¸€ä¸ªèŠ‚ç‚¹ã€‚åŒå‘é“¾è¡¨å¯ä»¥ä»ä¸¤ä¸ªæ–¹å‘éå†ï¼Œå¢åŠ äº†çµæ´»æ€§ã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>Structure of Doubly Linked List</strong><br>
                            Each node in a doubly linked list contains three parts: a data field, a previous pointer, and a next pointer. The previous pointer points to the previous node, and the next pointer points to the next node. Doubly linked lists can be traversed in both directions, adding flexibility.</p>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>åŒå‘é“¾è¡¨çš„åŸºæœ¬æ“ä½œåŠæ—¶é—´å¤æ‚åº¦</strong><br>
                            â€¢ æŸ¥æ‰¾ï¼šO(n)ï¼Œå¯ä»¥ä»å¤´æˆ–å°¾å¼€å§‹éå†<br>
                            <div class="code-block">
<pre><code class="language-c">// Cè¯­è¨€å®ç°åŒå‘é“¾è¡¨æŸ¥æ‰¾æ“ä½œ
Node* search(Node* head, int value) {
    Node* current = head;
    while (current != NULL) {
        if (current->data == value)
            return current;
        current = current->next;
    }
    return NULL;  // æœªæ‰¾åˆ°å…ƒç´ 
}</code></pre>
                            </div><br>
                            â€¢ æ’å…¥ï¼šO(1)ï¼Œå¦‚æœå·²çŸ¥æ’å…¥ä½ç½®çš„èŠ‚ç‚¹<br>
                            <div class="code-block">
<pre><code class="language-c">// Cè¯­è¨€å®ç°åŒå‘é“¾è¡¨æ’å…¥æ“ä½œ
void insertAfter(Node* node, int value) {
    if (node == NULL) return;
    
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = value;
    
    newNode->next = node->next;
    newNode->prev = node;
    
    if (node->next != NULL)
        node->next->prev = newNode;
        
    node->next = newNode;
}</code></pre>
                            </div><br>
                            â€¢ åˆ é™¤ï¼šO(1)ï¼Œå¦‚æœå·²çŸ¥åˆ é™¤ä½ç½®çš„èŠ‚ç‚¹<br>
                            <div class="code-block">
<pre><code class="language-c">// Cè¯­è¨€å®ç°åŒå‘é“¾è¡¨åˆ é™¤æ“ä½œ
void deleteNode(Node* node) {
    if (node == NULL) return;
    
    if (node->prev != NULL)
        node->prev->next = node->next;
        
    if (node->next != NULL)
        node->next->prev = node->prev;
        
    free(node);
}</code></pre>
                            </div><br>
                            â€¢ ä¿®æ”¹ï¼šO(n)ï¼Œéœ€è¦å…ˆæŸ¥æ‰¾åˆ°èŠ‚ç‚¹<br>
                            <div class="code-block">
<pre><code class="language-c">// Cè¯­è¨€å®ç°åŒå‘é“¾è¡¨ä¿®æ”¹æ“ä½œ
int modifyElement(Node* head, int oldValue, int newValue) {
    Node* node = search(head, oldValue);
    if (node != NULL) {
        node->data = newValue;
        return 1;
    }
    return 0;  // æœªæ‰¾åˆ°è¦ä¿®æ”¹çš„å…ƒç´ 
}</code></pre>
                            </div></p>
                            
                            <p class="en-content" style="display: none;"><strong>Basic Operations and Time Complexity of Doubly Linked Lists</strong><br>
                            â€¢ Search: O(n), can traverse from either head or tail<br>
                            â€¢ Insert: O(1), if the node at the insertion position is known<br>
                            â€¢ Delete: O(1), if the node at the deletion position is known<br>
                            â€¢ Modify: O(n), requires finding the node first</p>
                        </div>
                        
                        <h3 data-en="2.5 Common Algorithm Problems" data-zh="2.5 å¸¸è§ç®—æ³•é¢˜å‹">2.5 å¸¸è§ç®—æ³•é¢˜å‹</h3>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>1. æœ‰åºé“¾è¡¨åˆå¹¶</strong><br>
                            å°†ä¸¤ä¸ªå·²æ’åºçš„é“¾è¡¨åˆå¹¶ä¸ºä¸€ä¸ªæ–°çš„æœ‰åºé“¾è¡¨ã€‚è¿™æ˜¯ä¸€ä¸ªå¸¸è§çš„åŸºç¡€ç®—æ³•é—®é¢˜ï¼Œä¹Ÿæ˜¯å½’å¹¶æ’åºçš„æ ¸å¿ƒæ“ä½œã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>1. Merge Two Sorted Lists</strong><br>
                            Merge two sorted linked lists into a new sorted list. This is a common fundamental algorithm problem and also the core operation of merge sort.</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ï¼ˆCè¯­è¨€ï¼‰
struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) {
    struct ListNode dummy;
    struct ListNode* tail = &dummy;
    
    while (l1 && l2) {
        if (l1->val < l2->val) {
            tail->next = l1;
            l1 = l1->next;
        } else {
            tail->next = l2;
            l2 = l2->next;
        }
        tail = tail->next;
    }
    
    tail->next = l1 ? l1 : l2;
    return dummy.next;
}</code></pre>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>2. é“¾è¡¨é›†åˆæ“ä½œ - äº¤é›†</strong><br>
                            ç»™å®šä¸¤ä¸ªé“¾è¡¨ï¼Œæ±‚å®ƒä»¬çš„äº¤é›†ï¼ˆå³åœ¨ä¸¤ä¸ªé“¾è¡¨ä¸­éƒ½å‡ºç°çš„å…ƒç´ ï¼‰ã€‚é€šå¸¸å‡è®¾é“¾è¡¨ä¸­æ— é‡å¤å…ƒç´ ã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>2. Linked List Set Operations - Intersection</strong><br>
                            Given two linked lists, find their intersection (elements that appear in both lists). Usually assumes no duplicate elements in the lists.</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// æ±‚ä¸¤ä¸ªé“¾è¡¨çš„äº¤é›†ï¼ˆCè¯­è¨€ï¼‰
struct ListNode* getIntersection(struct ListNode* headA, struct ListNode* headB) {
    // ä½¿ç”¨å“ˆå¸Œè¡¨å­˜å‚¨ç¬¬ä¸€ä¸ªé“¾è¡¨çš„å€¼
    int hash[10000] = {0}; // å‡è®¾å€¼çš„èŒƒå›´åœ¨0-9999ä¹‹é—´
    struct ListNode dummy;
    struct ListNode* tail = &dummy;
    dummy.next = NULL;
    
    // å°†ç¬¬ä¸€ä¸ªé“¾è¡¨çš„æ‰€æœ‰å€¼æ ‡è®°åœ¨å“ˆå¸Œè¡¨ä¸­
    while (headA) {
        hash[headA->val] = 1;
        headA = headA->next;
    }
    
    // æ£€æŸ¥ç¬¬äºŒä¸ªé“¾è¡¨ä¸­çš„å€¼æ˜¯å¦åœ¨å“ˆå¸Œè¡¨ä¸­
    while (headB) {
        if (hash[headB->val] == 1) {
            struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));
            newNode->val = headB->val;
            newNode->next = NULL;
            
            tail->next = newNode;
            tail = tail->next;
            hash[headB->val] = 0; // é˜²æ­¢é‡å¤æ·»åŠ 
        }
        headB = headB->next;
    }
    
    return dummy.next;
}</code></pre>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>3. é“¾è¡¨é›†åˆæ“ä½œ - å¹¶é›†</strong><br>
                            ç»™å®šä¸¤ä¸ªé“¾è¡¨ï¼Œæ±‚å®ƒä»¬çš„å¹¶é›†ï¼ˆå³åŒ…å«ä¸¤ä¸ªé“¾è¡¨ä¸­æ‰€æœ‰ä¸é‡å¤çš„å…ƒç´ ï¼‰ã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>3. Linked List Set Operations - Union</strong><br>
                            Given two linked lists, find their union (all unique elements from both lists).</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// æ±‚ä¸¤ä¸ªé“¾è¡¨çš„å¹¶é›†ï¼ˆCè¯­è¨€ï¼‰
struct ListNode* getUnion(struct ListNode* headA, struct ListNode* headB) {
    int hash[10000] = {0}; // å‡è®¾å€¼çš„èŒƒå›´åœ¨0-9999ä¹‹é—´
    struct ListNode dummy;
    struct ListNode* tail = &dummy;
    dummy.next = NULL;
    
    // å¤„ç†ç¬¬ä¸€ä¸ªé“¾è¡¨
    while (headA) {
        if (hash[headA->val] == 0) {
            hash[headA->val] = 1;
            
            struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));
            newNode->val = headA->val;
            newNode->next = NULL;
            
            tail->next = newNode;
            tail = tail->next;
        }
        headA = headA->next;
    }
    
    // å¤„ç†ç¬¬äºŒä¸ªé“¾è¡¨
    while (headB) {
        if (hash[headB->val] == 0) {
            hash[headB->val] = 1;
            
            struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));
            newNode->val = headB->val;
            newNode->next = NULL;
            
            tail->next = newNode;
            tail = tail->next;
        }
        headB = headB->next;
    }
    
    return dummy.next;
}</code></pre>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>4. é“¾è¡¨é›†åˆæ“ä½œ - è¡¥é›†</strong><br>
                            ç»™å®šä¸¤ä¸ªé“¾è¡¨Aå’ŒBï¼Œæ±‚Aç›¸å¯¹äºBçš„è¡¥é›†ï¼ˆå³åœ¨Aä¸­å‡ºç°ä½†ä¸åœ¨Bä¸­å‡ºç°çš„å…ƒç´ ï¼‰ã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>4. Linked List Set Operations - Complement</strong><br>
                            Given two linked lists A and B, find the complement of A with respect to B (elements that appear in A but not in B).</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// æ±‚é“¾è¡¨Aç›¸å¯¹äºBçš„è¡¥é›†ï¼ˆCè¯­è¨€ï¼‰
struct ListNode* getComplement(struct ListNode* headA, struct ListNode* headB) {
    int hash[10000] = {0}; // å‡è®¾å€¼çš„èŒƒå›´åœ¨0-9999ä¹‹é—´
    struct ListNode dummy;
    struct ListNode* tail = &dummy;
    dummy.next = NULL;
    
    // å°†Bä¸­æ‰€æœ‰å…ƒç´ æ ‡è®°åœ¨å“ˆå¸Œè¡¨ä¸­
    while (headB) {
        hash[headB->val] = 1;
        headB = headB->next;
    }
    
    // æ£€æŸ¥Aä¸­çš„å…ƒç´ æ˜¯å¦ä¸åœ¨Bä¸­
    while (headA) {
        if (hash[headA->val] == 0) {
            struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));
            newNode->val = headA->val;
            newNode->next = NULL;
            
            tail->next = newNode;
            tail = tail->next;
        }
        headA = headA->next;
    }
    
    return dummy.next;
}</code></pre>
                        </div>
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>5. é“¾è¡¨åè½¬</strong><br>
                            å°†ä¸€ä¸ªå•å‘é“¾è¡¨åè½¬ï¼Œä½¿æ‰€æœ‰èŠ‚ç‚¹çš„æŒ‡å‘åå‘ã€‚è¿™æ˜¯é¢è¯•ä¸­çš„ç»å…¸é—®é¢˜ã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>5. Linked List Reversal</strong><br>
                            Reverse a singly linked list, changing the direction of all node pointers. This is a classic interview problem.</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// é“¾è¡¨åè½¬ä»£ç ç¤ºä¾‹ï¼ˆCè¯­è¨€ï¼‰
struct ListNode* reverseList(struct ListNode* head) {
    struct ListNode* prev = NULL;
    struct ListNode* curr = head;
    while (curr != NULL) {
        struct ListNode* next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}</code></pre>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>6. æ£€æµ‹ç¯å½¢é“¾è¡¨</strong><br>
                            åˆ¤æ–­ä¸€ä¸ªé“¾è¡¨æ˜¯å¦åŒ…å«ç¯ã€‚å¯ä»¥ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆï¼ˆFloyd's Cycle-Finding Algorithmï¼‰è§£å†³ã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>6. Detecting Cycle in a Linked List</strong><br>
                            Determine if a linked list contains a cycle. This can be solved using the fast and slow pointer technique (Floyd's Cycle-Finding Algorithm).</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// æ£€æµ‹ç¯å½¢é“¾è¡¨ä»£ç ç¤ºä¾‹ï¼ˆCè¯­è¨€ï¼‰
bool hasCycle(struct ListNode* head) {
    if (head == NULL || head->next == NULL) return false;
    
    struct ListNode* slow = head;
    struct ListNode* fast = head;
    
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) return true;
    }
    
    return false;
}</code></pre>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>7. æ‰¾å‡ºé“¾è¡¨çš„ä¸­é—´èŠ‚ç‚¹</strong><br>
                            æ‰¾å‡ºå•å‘é“¾è¡¨çš„ä¸­é—´èŠ‚ç‚¹ã€‚åŒæ ·å¯ä»¥ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆè§£å†³ã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>7. Finding the Middle Node of a Linked List</strong><br>
                            Find the middle node of a singly linked list. This can also be solved using the fast and slow pointer technique.</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// æ‰¾å‡ºé“¾è¡¨ä¸­é—´èŠ‚ç‚¹ä»£ç ç¤ºä¾‹ï¼ˆCè¯­è¨€ï¼‰
struct ListNode* middleNode(struct ListNode* head) {
    struct ListNode* slow = head;
    struct ListNode* fast = head;
    
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
    }
    
    return slow;
}</code></pre>
                        </div>
                        
                        <!-- ä»£ç ç¤ºä¾‹ï¼ˆå¦‚æœéœ€è¦ï¼‰ -->
                        <div class="code-block">
                            <pre><code class="language-c">// æ­¤å¤„æ·»åŠ ä»£ç ç¤ºä¾‹
void example() {
    printf("Hello, World!\n");
}</code></pre>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>ç¤ºä¾‹åˆ†æ</strong><br>
                            åˆ†æä¸Šè¿°ä»£ç æˆ–æ¦‚å¿µçš„åº”ç”¨ç¤ºä¾‹ï¼š</p>
                            
                            <p class="en-content" style="display: none;"><strong>Example Analysis</strong><br>
                            Analyze the application examples of the above code or concepts:</p>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>æ€»ç»“</strong><br>
                            å°èŠ‚å†…å®¹æ€»ç»“ <span class="emoji">ğŸ“</span></p>
                            
                            <p class="en-content" style="display: none;"><strong>Summary</strong><br>
                            Summary of the subsection content <span class="emoji">ğŸ“</span></p>
                        </div>
                        
                        <h3 data-en="2.2 Subsection Two" data-zh="2.2 å°èŠ‚äºŒ">2.2 å°èŠ‚äºŒ</h3>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>æ¦‚å¿µè§£é‡Š</strong><br>
                            åœ¨æ­¤å¤„è§£é‡Šç›¸å…³æ¦‚å¿µ</p>
                            
                            <p class="en-content" style="display: none;"><strong>Concept Explanation</strong><br>
                            Explain related concepts here</p>
                        </div>
                        
                        <!-- å›¾ç‰‡ç¤ºä¾‹ï¼ˆå¦‚æœéœ€è¦ï¼‰--> 
                        <div class="post-image">
                            <img src="../../images/example.jpg" alt="ç¤ºä¾‹å›¾ç‰‡" class="responsive-image">
                            <figcaption data-en="Example Image" data-zh="ç¤ºä¾‹å›¾ç‰‡">ç¤ºä¾‹å›¾ç‰‡</figcaption>
                        </div>
                    </section>
                    
                    <!-- ç¬¬ä¸‰éƒ¨åˆ† -->
                    <section id="section-3">
                        <h2 data-en="III. Stack" data-zh="ä¸‰ã€æ ˆ">ä¸‰ã€æ ˆ</h2>
                        
                        <div class="bilingual-content">
                            <p class="zh-content">æ ˆæ˜¯ä¸€ç§ç‰¹æ®Šçš„çº¿æ€§è¡¨ï¼Œå®ƒåªå…è®¸åœ¨ä¸€ç«¯ï¼ˆé€šå¸¸ç§°ä¸ºæ ˆé¡¶ï¼‰è¿›è¡Œæ’å…¥å’Œåˆ é™¤æ“ä½œã€‚æ ˆéµå¾ª"åè¿›å…ˆå‡º"ï¼ˆLast In First Outï¼ŒLIFOï¼‰çš„åŸåˆ™ï¼Œè¿™æ„å‘³ç€æœ€åæ”¾å…¥æ ˆä¸­çš„å…ƒç´ å°†ç¬¬ä¸€ä¸ªè¢«å–å‡ºã€‚</p>
                            
                            <p class="en-content" style="display: none;">A stack is a special type of linear list that only allows insertion and deletion operations at one end (usually called the top of the stack). Stacks follow the "Last In First Out" (LIFO) principle, which means that the last element placed in the stack will be the first one to be removed.</p>
                        </div>
                        
                        <h3 data-en="3.1 Stack Concept and Basic Operations" data-zh="3.1 æ ˆçš„æ¦‚å¿µä¸åŸºæœ¬æ“ä½œ">3.1 æ ˆçš„æ¦‚å¿µä¸åŸºæœ¬æ“ä½œ</h3>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>æ ˆçš„åŸºæœ¬æ¦‚å¿µ</strong><br>
                            æ ˆæ˜¯ä¸€ç§æŠ½è±¡æ•°æ®ç±»å‹ï¼Œå®ƒçš„åŸºæœ¬æ“ä½œåŒ…æ‹¬ï¼š<br>
                            â€¢ å‹æ ˆï¼ˆPushï¼‰ï¼šå°†å…ƒç´ æ·»åŠ åˆ°æ ˆé¡¶<br>
                            â€¢ å‡ºæ ˆï¼ˆPopï¼‰ï¼šç§»é™¤æ ˆé¡¶å…ƒç´ <br>
                            â€¢ è·å–æ ˆé¡¶å…ƒç´ ï¼ˆTop/Peekï¼‰ï¼šè¿”å›æ ˆé¡¶å…ƒç´ ä½†ä¸ç§»é™¤<br>
                            â€¢ åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©ºï¼ˆIsEmptyï¼‰ï¼šæ£€æŸ¥æ ˆä¸­æ˜¯å¦æœ‰å…ƒç´ </p>
                            
                            <p class="en-content" style="display: none;"><strong>Basic Concept of Stack</strong><br>
                            A stack is an abstract data type with the following basic operations:<br>
                            â€¢ Push: Add an element to the top of the stack<br>
                            â€¢ Pop: Remove the top element from the stack<br>
                            â€¢ Top/Peek: Return the top element without removing it<br>
                            â€¢ IsEmpty: Check if the stack contains any elements</p>
                        </div>
                        
                        <div class="post-image">
                            <img src="../../../images/stack-operation.jpg" alt="æ ˆæ“ä½œç¤ºæ„å›¾" class="responsive-image">
                            <figcaption data-en="Stack Operation Diagram" data-zh="æ ˆæ“ä½œç¤ºæ„å›¾">æ ˆæ“ä½œç¤ºæ„å›¾ <span class="emoji">ğŸ“š</span></figcaption>
                        </div>
                        
                        <h3 data-en="3.2 Implementation of Stack" data-zh="3.2 æ ˆçš„å®ç°æ–¹å¼">3.2 æ ˆçš„å®ç°æ–¹å¼</h3>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>é¡ºåºæ ˆï¼ˆæ•°ç»„å®ç°ï¼‰</strong><br>
                            é¡ºåºæ ˆä½¿ç”¨ä¸€ç»´æ•°ç»„æ¥å­˜å‚¨æ ˆä¸­çš„å…ƒç´ ï¼ŒåŒæ—¶ä½¿ç”¨ä¸€ä¸ªå˜é‡ï¼ˆé€šå¸¸ç§°ä¸ºtopï¼‰æ¥æŒ‡ç¤ºæ ˆé¡¶çš„ä½ç½®ã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>Sequential Stack (Array Implementation)</strong><br>
                            A sequential stack uses a one-dimensional array to store the elements in the stack, along with a variable (usually called top) to indicate the position of the top of the stack.</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// é¡ºåºæ ˆçš„Cè¯­è¨€å®ç°
#define MAX_SIZE 100

typedef struct {
    int data[MAX_SIZE];  // å­˜å‚¨æ ˆä¸­å…ƒç´ çš„æ•°ç»„
    int top;             // æ ˆé¡¶æŒ‡é’ˆ
} SeqStack;

// åˆå§‹åŒ–æ ˆ
void initStack(SeqStack *s) {
    s->top = -1;  // æ ˆé¡¶æŒ‡é’ˆåˆå§‹åŒ–ä¸º-1ï¼Œè¡¨ç¤ºç©ºæ ˆ
}

// åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©º
int isEmpty(SeqStack *s) {
    return s->top == -1;
}

// åˆ¤æ–­æ ˆæ˜¯å¦å·²æ»¡
int isFull(SeqStack *s) {
    return s->top == MAX_SIZE - 1;
}

// å…¥æ ˆæ“ä½œ
int push(SeqStack *s, int element) {
    if (isFull(s)) {
        return 0;  // æ ˆå·²æ»¡ï¼Œå…¥æ ˆå¤±è´¥
    }
    s->data[++(s->top)] = element;  // æ ˆé¡¶æŒ‡é’ˆåŠ 1ï¼Œç„¶åå­˜å…¥å…ƒç´ 
    return 1;  // å…¥æ ˆæˆåŠŸ
}

// å‡ºæ ˆæ“ä½œ
int pop(SeqStack *s, int *element) {
    if (isEmpty(s)) {
        return 0;  // æ ˆä¸ºç©ºï¼Œå‡ºæ ˆå¤±è´¥
    }
    *element = s->data[(s->top)--];  // å–å‡ºæ ˆé¡¶å…ƒç´ ï¼Œç„¶åæ ˆé¡¶æŒ‡é’ˆå‡1
    return 1;  // å‡ºæ ˆæˆåŠŸ
}

// è·å–æ ˆé¡¶å…ƒç´ ï¼ˆä¸å‡ºæ ˆï¼‰
int getTop(SeqStack *s, int *element) {
    if (isEmpty(s)) {
        return 0;  // æ ˆä¸ºç©ºï¼Œæ“ä½œå¤±è´¥
    }
    *element = s->data[s->top];  // å–å‡ºæ ˆé¡¶å…ƒç´ 
    return 1;  // æ“ä½œæˆåŠŸ
}</code></pre>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>é“¾å¼æ ˆï¼ˆé“¾è¡¨å®ç°ï¼‰</strong><br>
                            é“¾å¼æ ˆä½¿ç”¨é“¾è¡¨ç»“æ„å­˜å‚¨å…ƒç´ ï¼Œé€šå¸¸å°†é“¾è¡¨çš„å¤´éƒ¨ä½œä¸ºæ ˆé¡¶ï¼Œè¿™æ ·å¯ä»¥æ–¹ä¾¿åœ°è¿›è¡Œå…¥æ ˆå’Œå‡ºæ ˆæ“ä½œã€‚é“¾å¼æ ˆä¸ä¼šå­˜åœ¨æ ˆæ»¡çš„æƒ…å†µï¼Œåªè¦å†…å­˜è¶³å¤Ÿï¼Œå°±å¯ä»¥ä¸€ç›´å…¥æ ˆã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>Linked Stack (Linked List Implementation)</strong><br>
                            A linked stack uses a linked list structure to store elements, usually with the head of the linked list as the top of the stack, making it convenient for push and pop operations. A linked stack will never be full as long as there is enough memory available.</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// é“¾å¼æ ˆçš„Cè¯­è¨€å®ç°
typedef struct StackNode {
    int data;                  // æ•°æ®åŸŸ
    struct StackNode *next;    // æŒ‡é’ˆåŸŸ
} StackNode, *LinkStack;

// åˆå§‹åŒ–æ ˆ
void initStack(LinkStack *s) {
    *s = NULL;  // å¤´æŒ‡é’ˆä¸ºNULLè¡¨ç¤ºç©ºæ ˆ
}

// åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©º
int isEmpty(LinkStack s) {
    return s == NULL;
}

// å…¥æ ˆæ“ä½œ
void push(LinkStack *s, int element) {
    // åˆ›å»ºæ–°èŠ‚ç‚¹
    StackNode *node = (StackNode *)malloc(sizeof(StackNode));
    node->data = element;
    
    // æ–°èŠ‚ç‚¹æ’å…¥åˆ°æ ˆé¡¶ï¼ˆé“¾è¡¨å¤´éƒ¨ï¼‰
    node->next = *s;
    *s = node;
}

// å‡ºæ ˆæ“ä½œ
int pop(LinkStack *s, int *element) {
    if (isEmpty(*s)) {
        return 0;  // æ ˆä¸ºç©ºï¼Œå‡ºæ ˆå¤±è´¥
    }
    
    StackNode *temp = *s;  // æš‚å­˜æ ˆé¡¶èŠ‚ç‚¹
    *element = temp->data;  // è·å–æ ˆé¡¶å…ƒç´ å€¼
    *s = temp->next;        // æ ˆé¡¶æŒ‡é’ˆæŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
    free(temp);             // é‡Šæ”¾åŸæ ˆé¡¶èŠ‚ç‚¹
    return 1;  // å‡ºæ ˆæˆåŠŸ
}

// è·å–æ ˆé¡¶å…ƒç´ ï¼ˆä¸å‡ºæ ˆï¼‰
int getTop(LinkStack s, int *element) {
    if (isEmpty(s)) {
        return 0;  // æ ˆä¸ºç©ºï¼Œæ“ä½œå¤±è´¥
    }
    
    *element = s->data;  // è·å–æ ˆé¡¶å…ƒç´ å€¼
    return 1;  // æ“ä½œæˆåŠŸ
}</code></pre>
                        </div>
                        
                        <h3 data-en="3.3 Applications of Stack" data-zh="3.3 æ ˆçš„åº”ç”¨">3.3 æ ˆçš„åº”ç”¨</h3>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>1. è¡¨è¾¾å¼æ±‚å€¼</strong><br>
                            æ ˆå¯ä»¥ç”¨æ¥å¯¹ä¸­ç¼€è¡¨è¾¾å¼è¿›è¡Œæ±‚å€¼ã€‚é€šå¸¸çš„æ–¹æ³•æ˜¯å…ˆå°†ä¸­ç¼€è¡¨è¾¾å¼è½¬æ¢ä¸ºåç¼€è¡¨è¾¾å¼ï¼ˆé€†æ³¢å…°è¡¨ç¤ºæ³•ï¼‰ï¼Œç„¶åä½¿ç”¨æ ˆå¯¹åç¼€è¡¨è¾¾å¼æ±‚å€¼ã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>1. Expression Evaluation</strong><br>
                            Stacks can be used to evaluate infix expressions. The typical approach is to first convert the infix expression to a postfix expression (Reverse Polish Notation), and then use a stack to evaluate the postfix expression.</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// åç¼€è¡¨è¾¾å¼æ±‚å€¼çš„Cè¯­è¨€å®ç°
int evaluatePostfix(char* expression) {
    SeqStack stack;
    initStack(&stack);
    
    for (int i = 0; expression[i]; i++) {
        // å¦‚æœæ˜¯æ•°å­—ï¼Œå°†å…¶è½¬æ¢ä¸ºæ•´æ•°å¹¶å…¥æ ˆ
        if (isdigit(expression[i])) {
            push(&stack, expression[i] - '0');
        }
        // å¦‚æœæ˜¯è¿ç®—ç¬¦ï¼Œå¼¹å‡ºä¸¤ä¸ªæ“ä½œæ•°ï¼Œè¿›è¡Œè®¡ç®—ï¼Œç„¶åå°†ç»“æœå…¥æ ˆ
        else if (expression[i] == '+' || expression[i] == '-' || 
                 expression[i] == '*' || expression[i] == '/') {
            int val1, val2;
            pop(&stack, &val2);
            pop(&stack, &val1);
            
            switch (expression[i]) {
                case '+': push(&stack, val1 + val2); break;
                case '-': push(&stack, val1 - val2); break;
                case '*': push(&stack, val1 * val2); break;
                case '/': push(&stack, val1 / val2); break;
            }
        }
    }
    
    int result;
    pop(&stack, &result);
    return result;
}</code></pre>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>2. æ‹¬å·åŒ¹é…</strong><br>
                            æ ˆå¯ä»¥ç”¨æ¥æ£€æŸ¥æ‹¬å·è¡¨è¾¾å¼æ˜¯å¦æ­£ç¡®åµŒå¥—ã€‚å½“é‡åˆ°å·¦æ‹¬å·æ—¶å…¥æ ˆï¼Œé‡åˆ°å³æ‹¬å·æ—¶ä¸æ ˆé¡¶çš„å·¦æ‹¬å·åŒ¹é…å¹¶å‡ºæ ˆã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>2. Parenthesis Matching</strong><br>
                            Stacks can be used to check if parentheses in an expression are correctly nested. When a left parenthesis is encountered, it is pushed onto the stack; when a right parenthesis is encountered, it is matched with the left parenthesis at the top of the stack and popped.</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// æ‹¬å·åŒ¹é…æ£€æŸ¥çš„Cè¯­è¨€å®ç°
int checkParenthesis(char* expression) {
    SeqStack stack;
    initStack(&stack);
    
    for (int i = 0; expression[i]; i++) {
        char current = expression[i];
        
        // å¦‚æœæ˜¯å·¦æ‹¬å·ï¼Œå…¥æ ˆ
        if (current == '(' || current == '[' || current == '{') {
            push(&stack, current);
        }
        // å¦‚æœæ˜¯å³æ‹¬å·ï¼Œæ£€æŸ¥ä¸æ ˆé¡¶å…ƒç´ æ˜¯å¦åŒ¹é…
        else if (current == ')' || current == ']' || current == '}') {
            if (isEmpty(&stack)) {
                return 0;  // æ ˆä¸ºç©ºï¼Œæ²¡æœ‰åŒ¹é…çš„å·¦æ‹¬å·
            }
            
            int top;
            pop(&stack, &top);
            
            // æ£€æŸ¥æ‹¬å·æ˜¯å¦åŒ¹é…
            if ((current == ')' && top != '(') ||
                (current == ']' && top != '[') ||
                (current == '}' && top != '{')) {
                return 0;  // æ‹¬å·ä¸åŒ¹é…
            }
        }
    }
    
    // å¦‚æœæ ˆä¸ºç©ºï¼Œè¡¨ç¤ºæ‰€æœ‰æ‹¬å·éƒ½åŒ¹é…
    return isEmpty(&stack);
}</code></pre>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>3. å‡½æ•°è°ƒç”¨ä¸é€’å½’</strong><br>
                            è®¡ç®—æœºåœ¨å¤„ç†å‡½æ•°è°ƒç”¨æ—¶ä½¿ç”¨æ ˆæ¥ä¿å­˜å‡½æ•°è°ƒç”¨çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‚å½“ä¸€ä¸ªå‡½æ•°è°ƒç”¨å¦ä¸€ä¸ªå‡½æ•°æ—¶ï¼Œå½“å‰å‡½æ•°çš„çŠ¶æ€ï¼ˆå¦‚å±€éƒ¨å˜é‡ã€è¿”å›åœ°å€ç­‰ï¼‰ä¼šè¢«å‹å…¥æ ˆä¸­ï¼Œå‡½æ•°è¿”å›æ—¶å†ä»æ ˆä¸­æ¢å¤ã€‚é€’å½’å‡½æ•°å°±æ˜¯ä¾é è¿™ç§æœºåˆ¶å®ç°çš„ã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>3. Function Calls and Recursion</strong><br>
                            Computers use stacks to store context information for function calls. When one function calls another, the current function's state (such as local variables, return address, etc.) is pushed onto the stack, and restored when the function returns. Recursive functions rely on this mechanism to work.</p>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>3.1 é€’å½’ä¸éé€’å½’ç¤ºä¾‹ï¼šæ–æ³¢é‚£å¥‘æ•°åˆ—</strong><br>
                            æ–æ³¢é‚£å¥‘æ•°åˆ—æ˜¯ä¸€ä¸ªç»å…¸çš„é€’å½’é—®é¢˜ï¼Œæ¯ä¸ªæ•°æ˜¯å‰ä¸¤ä¸ªæ•°çš„å’Œï¼š1, 1, 2, 3, 5, 8, 13...ã€‚ä¸‹é¢å±•ç¤ºäº†è®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—çš„é€’å½’å®ç°å’ŒåŸºäºæ ˆçš„éé€’å½’å®ç°ã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>3.1 Recursive and Non-recursive Example: Fibonacci Sequence</strong><br>
                            The Fibonacci sequence is a classic recursion problem, where each number is the sum of the two preceding ones: 1, 1, 2, 3, 5, 8, 13.... Below are the recursive implementation and stack-based non-recursive implementation of the Fibonacci sequence calculation.</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// é€’å½’å®ç°æ–æ³¢é‚£å¥‘æ•°åˆ—
int fibRecursive(int n) {
    if (n <= 1) return n;
    return fibRecursive(n-1) + fibRecursive(n-2);
}

// åŸºäºæ ˆçš„éé€’å½’å®ç°
int fibNonRecursive(int n) {
    if (n <= 1) return n;
    
    // ä½¿ç”¨è¿­ä»£æ–¹æ³•è®¡ç®—
    int a = 0, b = 1, c;
    for (int i = 2; i <= n; i++) {
        c = a + b;
        a = b;
        b = c;
    }
    return b;
}</code></pre>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>3.2 é€’å½’ä¸éé€’å½’ç¤ºä¾‹ï¼šé˜¶ä¹˜è®¡ç®—</strong><br>
                            é˜¶ä¹˜æ˜¯å¦ä¸€ä¸ªç»å…¸çš„é€’å½’åº”ç”¨ï¼šn! = n * (n-1)!ã€‚ä¸‹é¢å±•ç¤ºäº†è®¡ç®—é˜¶ä¹˜çš„é€’å½’å®ç°å’ŒåŸºäºæ ˆçš„éé€’å½’å®ç°ã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>3.2 Recursive and Non-recursive Example: Factorial Calculation</strong><br>
                            Factorial is another classic application of recursion: n! = n * (n-1)!. Below are the recursive implementation and stack-based non-recursive implementation of factorial calculation.</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// é€’å½’å®ç°é˜¶ä¹˜
int factorialRecursive(int n) {
    if (n <= 1) return 1;
    return n * factorialRecursive(n-1);
}

// åŸºäºæ ˆçš„éé€’å½’å®ç°
int factorialNonRecursive(int n) {
    int result = 1;
    for (int i = 2; i <= n; i++) {
        result *= i;
    }
    return result;
}</code></pre>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>3.3 é€’å½’ä¸éé€’å½’ç¤ºä¾‹ï¼šæ±‰è¯ºå¡”é—®é¢˜</strong><br>
                            æ±‰è¯ºå¡”æ˜¯ä¸€ä¸ªè‘—åçš„é€’å½’é—®é¢˜ï¼Œç›®æ ‡æ˜¯å°†ä¸€ç»„ä»å°åˆ°å¤§æ’åˆ—çš„åœ†ç›˜ä»ä¸€æ ¹æŸ±å­ç§»åŠ¨åˆ°å¦ä¸€æ ¹æŸ±å­ï¼Œè¿‡ç¨‹ä¸­å¯ä»¥ä½¿ç”¨ç¬¬ä¸‰æ ¹æŸ±å­ä½œä¸ºè¾…åŠ©ï¼Œä½†ä¸èƒ½å°†å¤§åœ†ç›˜æ”¾åœ¨å°åœ†ç›˜ä¸Šã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>3.3 Recursive and Non-recursive Example: Tower of Hanoi</strong><br>
                            The Tower of Hanoi is a famous recursion problem. The goal is to move a stack of disks from one rod to another, using a third rod as auxiliary. A larger disk cannot be placed on top of a smaller disk.</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// é€’å½’å®ç°æ±‰è¯ºå¡”
void hanoiRecursive(int n, char from_rod, char to_rod, char aux_rod) {
    if (n == 1) {
        printf("ç§»åŠ¨åœ†ç›˜ 1 ä» %c åˆ° %c\n", from_rod, to_rod);
        return;
    }
    hanoiRecursive(n-1, from_rod, aux_rod, to_rod);
    printf("ç§»åŠ¨åœ†ç›˜ %d ä» %c åˆ° %c\n", n, from_rod, to_rod);
    hanoiRecursive(n-1, aux_rod, to_rod, from_rod);
}

// éé€’å½’ï¼ˆæ ˆï¼‰å®ç°æ±‰è¯ºå¡”
void hanoiNonRecursive(int n, char from_rod, char to_rod, char aux_rod) {
    typedef struct {
        int n;
        char from_rod;
        char to_rod;
        char aux_rod;
        int state; // 0:åˆå§‹çŠ¶æ€, 1:ç§»åŠ¨äº†n-1ä¸ªç›˜å­åˆ°è¾…åŠ©æŸ±, 2:ç§»åŠ¨äº†ç¬¬nä¸ªç›˜å­
    } Frame;
    
    SeqStack stack;
    initStack(&stack);
    
    // åˆ›å»ºåˆå§‹æ ˆå¸§
    Frame* framePtr = (Frame*)malloc(sizeof(Frame));
    framePtr->n = n;
    framePtr->from_rod = from_rod;
    framePtr->to_rod = to_rod;
    framePtr->aux_rod = aux_rod;
    framePtr->state = 0;
    
    push(&stack, (int)framePtr);
    
    while (!isEmpty(&stack)) {
        int currentFramePtr;
        getTop(&stack, &currentFramePtr);
        Frame* currentFrame = (Frame*)currentFramePtr;
        
        if (currentFrame->n == 1) {
            // åŸºæœ¬æƒ…å†µ
            printf("ç§»åŠ¨åœ†ç›˜ 1 ä» %c åˆ° %c\n", currentFrame->from_rod, currentFrame->to_rod);
            pop(&stack, &currentFramePtr);
            free(currentFrame);
        } else if (currentFrame->state == 0) {
            // å°†n-1ä¸ªç›˜å­ä»èµ·å§‹æŸ±ç§»åˆ°è¾…åŠ©æŸ±
            currentFrame->state = 1;
            Frame* newFrame = (Frame*)malloc(sizeof(Frame));
            newFrame->n = currentFrame->n - 1;
            newFrame->from_rod = currentFrame->from_rod;
            newFrame->to_rod = currentFrame->aux_rod;
            newFrame->aux_rod = currentFrame->to_rod;
            newFrame->state = 0;
            push(&stack, (int)newFrame);
        } else if (currentFrame->state == 1) {
            // å°†ç¬¬nä¸ªç›˜å­ä»èµ·å§‹æŸ±ç§»åˆ°ç›®æ ‡æŸ±
            printf("ç§»åŠ¨åœ†ç›˜ %d ä» %c åˆ° %c\n", currentFrame->n, currentFrame->from_rod, currentFrame->to_rod);
            currentFrame->state = 2;
            Frame* newFrame = (Frame*)malloc(sizeof(Frame));
            newFrame->n = currentFrame->n - 1;
            newFrame->from_rod = currentFrame->aux_rod;
            newFrame->to_rod = currentFrame->to_rod;
            newFrame->aux_rod = currentFrame->from_rod;
            newFrame->state = 0;
            push(&stack, (int)newFrame);
        } else {
            // å®Œæˆæ‰€æœ‰ç§»åŠ¨
            pop(&stack, &currentFramePtr);
            free(currentFrame);
        }
    }
}</code></pre>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>3.4 é€’å½’ä¸éé€’å½’ç¤ºä¾‹ï¼šäºŒå‰æ ‘éå†</strong><br>
                            äºŒå‰æ ‘çš„éå†æ˜¯é€’å½’çš„ä¸€ä¸ªé‡è¦åº”ç”¨ï¼ŒåŒ…æ‹¬å‰åºéå†ï¼ˆæ ¹-å·¦-å³ï¼‰ã€ä¸­åºéå†ï¼ˆå·¦-æ ¹-å³ï¼‰å’Œååºéå†ï¼ˆå·¦-å³-æ ¹ï¼‰ã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>3.4 Recursive and Non-recursive Example: Binary Tree Traversal</strong><br>
                            Binary tree traversal is an important application of recursion, including preorder (root-left-right), inorder (left-root-right), and postorder (left-right-root) traversal.</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// äºŒå‰æ ‘èŠ‚ç‚¹ç»“æ„
typedef struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;

// é€’å½’å®ç°å‰åºéå†
void preorderRecursive(TreeNode* root) {
    if (root == NULL) return;
    printf("%d ", root->val);       // è®¿é—®æ ¹èŠ‚ç‚¹
    preorderRecursive(root->left);  // éå†å·¦å­æ ‘
    preorderRecursive(root->right); // éå†å³å­æ ‘
}

// éé€’å½’ï¼ˆæ ˆï¼‰å®ç°å‰åºéå†
void preorderNonRecursive(TreeNode* root) {
    if (root == NULL) return;
    
    SeqStack stack;
    initStack(&stack);
    push(&stack, (int)root);
    
    while (!isEmpty(&stack)) {
        int nodePtr;
        pop(&stack, &nodePtr);
        TreeNode* node = (TreeNode*)nodePtr;
        
        printf("%d ", node->val); // è®¿é—®èŠ‚ç‚¹
        
        // ç”±äºæ ˆæ˜¯åè¿›å…ˆå‡ºï¼Œæ‰€ä»¥å…ˆå‹å…¥å³å­èŠ‚ç‚¹ï¼Œå†å‹å…¥å·¦å­èŠ‚ç‚¹
        if (node->right != NULL) {
            push(&stack, (int)node->right);
        }
        if (node->left != NULL) {
            push(&stack, (int)node->left);
        }
    }
}

// é€’å½’å®ç°ä¸­åºéå†
void inorderRecursive(TreeNode* root) {
    if (root == NULL) return;
    inorderRecursive(root->left);  // éå†å·¦å­æ ‘
    printf("%d ", root->val);      // è®¿é—®æ ¹èŠ‚ç‚¹
    inorderRecursive(root->right); // éå†å³å­æ ‘
}

// éé€’å½’ï¼ˆæ ˆï¼‰å®ç°ä¸­åºéå†
void inorderNonRecursive(TreeNode* root) {
    if (root == NULL) return;
    
    SeqStack stack;
    initStack(&stack);
    TreeNode* current = root;
    
    while (current != NULL || !isEmpty(&stack)) {
        // å°†å½“å‰èŠ‚ç‚¹åŠå…¶æ‰€æœ‰å·¦å­èŠ‚ç‚¹å…¥æ ˆ
        while (current != NULL) {
            push(&stack, (int)current);
            current = current->left;
        }
        
        // å¼¹å‡ºæ ˆé¡¶èŠ‚ç‚¹å¹¶è®¿é—®
        int nodePtr;
        pop(&stack, &nodePtr);
        current = (TreeNode*)nodePtr;
        printf("%d ", current->val);
        
        // å¤„ç†å³å­æ ‘
        current = current->right;
    }
}</code></pre>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>3.5 é€’å½’ä¸éé€’å½’æ€§èƒ½æ¯”è¾ƒ</strong><br>
                            é€’å½’å®ç°é€šå¸¸æ›´ç®€æ´æ˜“æ‡‚ï¼Œä½†åœ¨å®é™…åº”ç”¨ä¸­ï¼Œé€’å½’å¯èƒ½å¯¼è‡´æ ˆæº¢å‡ºæˆ–æ€§èƒ½é—®é¢˜ã€‚éé€’å½’å®ç°ï¼ˆä½¿ç”¨æ˜¾å¼æ ˆï¼‰é€šå¸¸æ›´é«˜æ•ˆï¼Œå°¤å…¶æ˜¯åœ¨å¤„ç†å¤§è§„æ¨¡é—®é¢˜æ—¶ï¼Œå› ä¸ºå®ƒé¿å…äº†é¢‘ç¹çš„å‡½æ•°è°ƒç”¨å¼€é”€ï¼Œæ›´å¥½åœ°æ§åˆ¶äº†å†…å­˜çš„ä½¿ç”¨ã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>3.5 Performance Comparison between Recursive and Non-recursive Approaches</strong><br>
                            Recursive implementations are usually more concise and easier to understand, but in practical applications, recursion may lead to stack overflow or performance issues. Non-recursive implementations (using explicit stacks) are usually more efficient, especially when dealing with large-scale problems, as they avoid the overhead of frequent function calls and provide better control over memory usage.</p>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>4. æµè§ˆå™¨çš„å‰è¿›åé€€åŠŸèƒ½</strong><br>
                            æµè§ˆå™¨çš„å†å²è®°å½•é€šå¸¸ä½¿ç”¨ä¸¤ä¸ªæ ˆæ¥å®ç°ï¼šä¸€ä¸ªç”¨äºå­˜å‚¨åé€€çš„é¡µé¢ï¼Œå¦ä¸€ä¸ªç”¨äºå­˜å‚¨å‰è¿›çš„é¡µé¢ã€‚å½“ç”¨æˆ·è®¿é—®æ–°é¡µé¢æ—¶ï¼Œå°†å½“å‰é¡µé¢å‹å…¥åé€€æ ˆï¼›å½“ç”¨æˆ·ç‚¹å‡»åé€€æŒ‰é’®æ—¶ï¼Œå°†å½“å‰é¡µé¢ä»åé€€æ ˆå¼¹å‡ºå¹¶å‹å…¥å‰è¿›æ ˆã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>4. Browser Forward and Back Buttons</strong><br>
                            Browser history is typically implemented using two stacks: one for back pages and another for forward pages. When a user visits a new page, the current page is pushed onto the back stack; when the user clicks the back button, the current page is popped from the back stack and pushed onto the forward stack.</p>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>5. æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰</strong><br>
                            æ·±åº¦ä¼˜å…ˆæœç´¢æ˜¯ä¸€ç§å›¾çš„éå†ç®—æ³•ï¼Œå®ƒä½¿ç”¨æ ˆæ¥è®°å½•éå†è¿‡ç¨‹ä¸­è®¿é—®çš„èŠ‚ç‚¹ã€‚ç®—æ³•é¦–å…ˆè®¿é—®èµ·å§‹èŠ‚ç‚¹ï¼Œç„¶åæ²¿ç€ä¸€æ¡è·¯å¾„å°½å¯èƒ½æ·±å…¥ï¼Œç›´åˆ°æ— æ³•ç»§ç»­å‰è¿›ï¼Œç„¶åå›æº¯åˆ°ä¸Šä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¯»æ‰¾æ–°çš„è·¯å¾„ã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>5. Depth-First Search (DFS)</strong><br>
                            Depth-First Search is a graph traversal algorithm that uses a stack to record nodes visited during the traversal. The algorithm first visits the starting node, then goes as deep as possible along a path until it cannot go further, then backtracks to the previous node to find new paths.</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// ä½¿ç”¨æ ˆå®ç°æ·±åº¦ä¼˜å…ˆæœç´¢çš„Cè¯­è¨€å®ç°
void DFS(int graph[MAX_VERTICES][MAX_VERTICES], int startVertex, int vertices) {
    int visited[MAX_VERTICES] = {0};
    SeqStack stack;
    initStack(&stack);
    
    // è®¿é—®èµ·å§‹èŠ‚ç‚¹å¹¶å°†å…¶æ ‡è®°ä¸ºå·²è®¿é—®
    printf("è®¿é—®èŠ‚ç‚¹: %d\n", startVertex);
    visited[startVertex] = 1;
    push(&stack, startVertex);
    
    while (!isEmpty(&stack)) {
        // è·å–æ ˆé¡¶å…ƒç´ ï¼ˆä½†ä¸å‡ºæ ˆï¼‰
        int currentVertex;
        getTop(&stack, &currentVertex);
        
        // å¯»æ‰¾å½“å‰é¡¶ç‚¹çš„æœªè®¿é—®é‚»å±…
        int i;
        for (i = 0; i < vertices; i++) {
            if (graph[currentVertex][i] == 1 && !visited[i]) {
                // è®¿é—®å¹¶æ ‡è®°é‚»å±…èŠ‚ç‚¹
                printf("è®¿é—®èŠ‚ç‚¹: %d\n", i);
                visited[i] = 1;
                push(&stack, i);
                break;
            }
        }
        
        // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æœªè®¿é—®çš„é‚»å±…ï¼Œåˆ™å›æº¯ï¼ˆå‡ºæ ˆï¼‰
        if (i == vertices) {
            pop(&stack, &currentVertex);
        }
    }
}</code></pre>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>6. æ’¤é”€/é‡åšåŠŸèƒ½</strong><br>
                            æ–‡æœ¬ç¼–è¾‘å™¨å’Œå›¾å½¢è®¾è®¡è½¯ä»¶ç­‰åº”ç”¨ä¸­çš„æ’¤é”€å’Œé‡åšåŠŸèƒ½ä¹Ÿæ˜¯ä½¿ç”¨æ ˆæ¥å®ç°çš„ã€‚æ¯æ¬¡æ“ä½œéƒ½ä¼šè¢«å‹å…¥"æ’¤é”€æ ˆ"ï¼Œå½“ç”¨æˆ·ç‚¹å‡»æ’¤é”€æ—¶ï¼Œä»æ’¤é”€æ ˆå¼¹å‡ºæ“ä½œå¹¶å‹å…¥"é‡åšæ ˆ"ã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>6. Undo/Redo Functionality</strong><br>
                            The undo and redo functionality in applications such as text editors and graphic design software is also implemented using stacks. Each operation is pushed onto an "undo stack", and when the user clicks undo, the operation is popped from the undo stack and pushed onto a "redo stack".</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// ç®€å•çš„æ’¤é”€/é‡åšåŠŸèƒ½å®ç°
typedef struct {
    char operation[100];
    char data[100];
} Action;

typedef struct {
    Action actions[MAX_SIZE];
    int top;
} ActionStack;

// åˆå§‹åŒ–æ“ä½œæ ˆ
void initActionStack(ActionStack *s) {
    s->top = -1;
}

// å°†æ“ä½œå‹å…¥æ ˆ
void pushAction(ActionStack *s, const char *operation, const char *data) {
    if (s->top < MAX_SIZE - 1) {
        s->top++;
        strcpy(s->actions[s->top].operation, operation);
        strcpy(s->actions[s->top].data, data);
    }
}

// å¼¹å‡ºæ ˆé¡¶æ“ä½œ
int popAction(ActionStack *s, Action *action) {
    if (s->top >= 0) {
        *action = s->actions[s->top];
        s->top--;
        return 1;
    }
    return 0;
}

// æ’¤é”€æ“ä½œ
void undo(ActionStack *undoStack, ActionStack *redoStack) {
    Action action;
    if (popAction(undoStack, &action)) {
        pushAction(redoStack, action.operation, action.data);
        printf("æ’¤é”€æ“ä½œ: %s, æ•°æ®: %s\n", action.operation, action.data);
        // æ‰§è¡Œæ’¤é”€é€»è¾‘...
    } else {
        printf("æ²¡æœ‰å¯æ’¤é”€çš„æ“ä½œ\n");
    }
}

// é‡åšæ“ä½œ
void redo(ActionStack *undoStack, ActionStack *redoStack) {
    Action action;
    if (popAction(redoStack, &action)) {
        pushAction(undoStack, action.operation, action.data);
        printf("é‡åšæ“ä½œ: %s, æ•°æ®: %s\n", action.operation, action.data);
        // æ‰§è¡Œé‡åšé€»è¾‘...
    } else {
        printf("æ²¡æœ‰å¯é‡åšçš„æ“ä½œ\n");
    }
}</code></pre>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>7. å•è°ƒæ ˆ</strong><br>
                            å•è°ƒæ ˆæ˜¯ä¸€ç§ç‰¹æ®Šçš„æ ˆï¼Œåœ¨è¿™ç§æ ˆä¸­ï¼Œå…ƒç´ ä»¥å•è°ƒé€’å¢æˆ–å•è°ƒé€’å‡çš„é¡ºåºæ’åˆ—ã€‚å•è°ƒæ ˆé€šå¸¸ç”¨äºè§£å†³"ä¸‹ä¸€ä¸ªæ›´å¤§/æ›´å°å…ƒç´ "ç±»å‹çš„é—®é¢˜ã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>7. Monotonic Stack</strong><br>
                            A monotonic stack is a special type of stack where elements are arranged in monotonically increasing or decreasing order. Monotonic stacks are typically used to solve "next greater/smaller element" type problems.</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// ä½¿ç”¨å•è°ƒæ ˆæŸ¥æ‰¾æ¯ä¸ªå…ƒç´ çš„ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ 
int* nextGreaterElement(int* nums, int numsSize, int* returnSize) {
    int* result = (int*)malloc(sizeof(int) * numsSize);
    *returnSize = numsSize;
    
    // åˆå§‹åŒ–ç»“æœæ•°ç»„ä¸º-1
    for (int i = 0; i < numsSize; i++) {
        result[i] = -1;
    }
    
    // åˆ›å»ºå•è°ƒé€’å‡æ ˆ
    SeqStack stack;
    initStack(&stack);
    
    for (int i = 0; i < numsSize; i++) {
        // å½“å‰å…ƒç´ å¤§äºæ ˆé¡¶å…ƒç´ æ—¶ï¼Œæ‰¾åˆ°äº†æ ˆé¡¶å…ƒç´ çš„ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ 
        while (!isEmpty(&stack)) {
            int top;
            getTop(&stack, &top);
            
            if (nums[i] > nums[top]) {
                pop(&stack, &top);
                result[top] = nums[i];
            } else {
                break;
            }
        }
        
        // å°†å½“å‰å…ƒç´ çš„ç´¢å¼•å‹å…¥æ ˆ
        push(&stack, i);
    }
    
    return result;
}</code></pre>
                        </div>
                        
                        <h3 data-en="3.4 Classic Stack Problems" data-zh="3.4 ç»å…¸æ ˆé¢˜ç›®">3.4 ç»å…¸æ ˆé¢˜ç›®</h3>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>1. æœ€å°æ ˆ</strong><br>
                            è®¾è®¡ä¸€ä¸ªæ”¯æŒpushã€popã€topæ“ä½œï¼Œå¹¶èƒ½åœ¨å¸¸æ•°æ—¶é—´å†…æ£€ç´¢åˆ°æœ€å°å…ƒç´ çš„æ ˆã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>1. Min Stack</strong><br>
                            Design a stack that supports push, pop, top operations, and retrieving the minimum element in constant time.</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// æœ€å°æ ˆçš„Cè¯­è¨€å®ç°
typedef struct {
    SeqStack dataStack;  // å­˜å‚¨æ‰€æœ‰å…ƒç´ çš„æ ˆ
    SeqStack minStack;   // å­˜å‚¨æœ€å°å€¼çš„æ ˆ
} MinStack;

// åˆå§‹åŒ–æœ€å°æ ˆ
void minStackInit(MinStack *obj) {
    initStack(&obj->dataStack);
    initStack(&obj->minStack);
}

// å…¥æ ˆæ“ä½œ
void minStackPush(MinStack *obj, int val) {
    push(&obj->dataStack, val);
    
    // å¦‚æœæœ€å°å€¼æ ˆä¸ºç©ºæˆ–å½“å‰å…ƒç´ ä¸å¤§äºæœ€å°å€¼æ ˆé¡¶å…ƒç´ ï¼Œåˆ™å…¥æ ˆ
    if (isEmpty(&obj->minStack)) {
        push(&obj->minStack, val);
    } else {
        int minTop;
        getTop(&obj->minStack, &minTop);
        if (val <= minTop) {
            push(&obj->minStack, val);
        }
    }
}

// å‡ºæ ˆæ“ä½œ
void minStackPop(MinStack *obj) {
    if (isEmpty(&obj->dataStack)) {
        return;
    }
    
    // è·å–å¹¶å¼¹å‡ºæ•°æ®æ ˆçš„æ ˆé¡¶å…ƒç´ 
    int topElement;
    pop(&obj->dataStack, &topElement);
    
    // å¦‚æœè¯¥å…ƒç´ ç­‰äºæœ€å°å€¼æ ˆçš„æ ˆé¡¶å…ƒç´ ï¼Œä¹Ÿå¼¹å‡ºæœ€å°å€¼æ ˆçš„æ ˆé¡¶
    int minTop;
    getTop(&obj->minStack, &minTop);
    if (topElement == minTop) {
        pop(&obj->minStack, &minTop);
    }
}

// è·å–æ ˆé¡¶å…ƒç´ 
int minStackTop(MinStack *obj) {
    int topElement;
    getTop(&obj->dataStack, &topElement);
    return topElement;
}

// è·å–æ ˆä¸­çš„æœ€å°å…ƒç´ 
int minStackGetMin(MinStack *obj) {
    int minElement;
    getTop(&obj->minStack, &minElement);
    return minElement;
}</code></pre>
                        </div>
                        
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>2. ç”¨æ ˆå®ç°é˜Ÿåˆ—</strong><br>
                            ä½¿ç”¨ä¸¤ä¸ªæ ˆå®ç°é˜Ÿåˆ—çš„åŠŸèƒ½ï¼Œæ”¯æŒé˜Ÿåˆ—çš„å…¥é˜Ÿï¼ˆpushï¼‰å’Œå‡ºé˜Ÿï¼ˆpopï¼‰æ“ä½œã€‚</p>
                            
                            <p class="en-content" style="display: none;"><strong>2. Implement Queue using Stacks</strong><br>
                            Implement a queue using two stacks, supporting the enqueue (push) and dequeue (pop) operations.</p>
                        </div>
                        
                        <div class="code-block">
                            <pre><code class="language-c">// ç”¨æ ˆå®ç°é˜Ÿåˆ—çš„Cè¯­è¨€å®ç°
typedef struct {
    SeqStack stackIn;   // ç”¨äºå…¥é˜Ÿæ“ä½œçš„æ ˆ
    SeqStack stackOut;  // ç”¨äºå‡ºé˜Ÿæ“ä½œçš„æ ˆ
} MyQueue;

// åˆå§‹åŒ–é˜Ÿåˆ—
void myQueueInit(MyQueue *obj) {
    initStack(&obj->stackIn);
    initStack(&obj->stackOut);
}

// å…¥é˜Ÿæ“ä½œ
void myQueuePush(MyQueue *obj, int x) {
    push(&obj->stackIn, x);
}

// å°†å…¥é˜Ÿæ ˆçš„å…ƒç´ ç§»åˆ°å‡ºé˜Ÿæ ˆ
void transfer(MyQueue *obj) {
    // åªæœ‰å½“å‡ºé˜Ÿæ ˆä¸ºç©ºæ—¶æ‰éœ€è¦è½¬ç§»
    if (isEmpty(&obj->stackOut)) {
        int element;
        // å°†å…¥é˜Ÿæ ˆçš„æ‰€æœ‰å…ƒç´ å¼¹å‡ºå¹¶å‹å…¥å‡ºé˜Ÿæ ˆ
        while (!isEmpty(&obj->stackIn)) {
            pop(&obj->stackIn, &element);
            push(&obj->stackOut, element);
        }
    }
}

// å‡ºé˜Ÿæ“ä½œ
int myQueuePop(MyQueue *obj) {
    transfer(obj);  // ç¡®ä¿å‡ºé˜Ÿæ ˆæœ‰å…ƒç´ 
    int element;
    pop(&obj->stackOut, &element);
    return element;
}

// æŸ¥çœ‹é˜Ÿé¦–å…ƒç´ 
int myQueuePeek(MyQueue *obj) {
    transfer(obj);  // ç¡®ä¿å‡ºé˜Ÿæ ˆæœ‰å…ƒç´ 
    int element;
    getTop(&obj->stackOut, &element);
    return element;
}

// åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
int myQueueEmpty(MyQueue *obj) {
    return isEmpty(&obj->stackIn) && isEmpty(&obj->stackOut);
}</code></pre>
                        </div>
                        
                        <!-- æ€»ç»“ -->
                        <div class="bilingual-content">
                            <p class="zh-content"><strong>æ ˆçš„ä¼˜ç¼ºç‚¹</strong></p>
                            <ul class="zh-content">
                                <li>ä¼˜ç‚¹ï¼šå®ç°ç®€å•ï¼Œæ“ä½œé«˜æ•ˆï¼ˆO(1)æ—¶é—´å¤æ‚åº¦ï¼‰</li>
                                <li>ä¼˜ç‚¹ï¼šç¬¦åˆç‰¹å®šçš„å¤„ç†é€»è¾‘ï¼ˆLIFOåŸåˆ™ï¼‰</li>
                                <li>ç¼ºç‚¹ï¼šåªèƒ½è®¿é—®æ ˆé¡¶å…ƒç´ ï¼Œè®¿é—®å…¶ä»–å…ƒç´ éœ€è¦è¿›è¡Œå‡ºæ ˆæ“ä½œ</li>
                            </ul>
                            
                            <p class="en-content" style="display: none;"><strong>Advantages and Disadvantages of Stacks</strong></p>
                            <ul class="en-content" style="display: none;">
                                <li>Advantage: Simple implementation, efficient operations (O(1) time complexity)</li>
                                <li>Advantage: Aligns with specific processing logic (LIFO principle)</li>
                                <li>Disadvantage: Can only access the top element; accessing other elements requires pop operations</li>
                            </ul>
                        </div>
                    </section>
                    
                    <!-- ç»“è¯­ -->
                    <div class="post-conclusion">
                        <h2 data-en="Conclusion" data-zh="ç»“è¯­">ç»“è¯­</h2>
                        
                        <div class="bilingual-content">
                            <p class="zh-content">æ€»ç»“æ–‡ç« çš„ä¸»è¦è§‚ç‚¹å’Œç»“è®ºã€‚æä¾›è¿›ä¸€æ­¥æ€è€ƒæˆ–åç»­å­¦ä¹ çš„å»ºè®®ã€‚</p>
                            
                            <p class="en-content" style="display: none;">Summarize the main points and conclusions of the article. Provide suggestions for further thinking or subsequent learning.</p>
                            
                            <p class="zh-content">æ„Ÿè°¢é˜…è¯»ï¼å¦‚æœ‰é—®é¢˜æˆ–å»ºè®®ï¼Œæ¬¢è¿åœ¨è¯„è®ºåŒºç•™è¨€ã€‚ <span class="emoji">ğŸ’»âœ¨</span></p>
                            
                            <p class="en-content" style="display: none;">Thanks for reading! If you have any questions or suggestions, please leave a message in the comments section. <span class="emoji">ğŸ’»âœ¨</span></p>
                        </div>
                        
                        <div class="post-signature">
                            <p>â€” HealthJian <span class="emoji">âœï¸</span></p>
                        </div>
                    </div>
                </div>
            </article>
            
            <!-- è¯„è®ºåŒº -->
            <div class="comments-section">
                <h3 data-en="Comments" data-zh="è¯„è®º">è¯„è®º</h3>
                <div class="comment-form">
                    <textarea placeholder="å†™ä¸‹ä½ çš„æƒ³æ³•..." data-en-placeholder="Write your thoughts..." data-zh-placeholder="å†™ä¸‹ä½ çš„æƒ³æ³•..."></textarea>
                    <button data-en="Submit" data-zh="æäº¤">æäº¤</button>
                </div>
                <div class="comments-container">
                    <p class="no-comments" data-en="Be the first to comment!" data-zh="æˆä¸ºç¬¬ä¸€ä¸ªè¯„è®ºçš„äººï¼">æˆä¸ºç¬¬ä¸€ä¸ªè¯„è®ºçš„äººï¼ <span class="emoji">ğŸ‰</span></p>
                </div>
            </div>
        </main>
    </div>

    <!-- é¡µè„š -->
    <footer>
        <div class="footer-content">
            <div class="footer-info">
                <p>&copy; 2025 CaiNiaojian&HealthJian all followed.</p>
                <p data-en="Contact: " data-zh="è”ç³»æ–¹å¼ï¼š">è”ç³»æ–¹å¼ï¼š<a href="mailto:gaojian1573@foxmail.com">gaojian1573@foxmail.com</a></p>
                <p data-en="Location: " data-zh="åœ°å€ï¼š">åœ°å€ï¼šXX</p>
            </div>
            <div class="footer-links">
                <a href="../../../blog.html" data-en="Blog" data-zh="åšå®¢">åšå®¢</a>
                <a href="../../../about.html" data-en="About" data-zh="å…³äº">å…³äº</a>
                <a href="https://github.com/CaiNiaojian" target="_blank" data-en="GitHub" data-zh="GitHub">GitHub</a>
                <a href="../../../changelog.html" data-en="ChangeLog" data-zh="æ›´æ–°æ—¥å¿—">æ›´æ–°æ—¥å¿—</a>
            </div>
        </div>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // åˆå§‹åŒ–ä»£ç é«˜äº®
            hljs.highlightAll();
        });
    </script>
    <script src="../../../js/main.js"></script>
    <script src="../../../js/theme.js"></script>
    <script src="../../../js/language.js"></script>
    <script src="../../../js/blog-post.js"></script>
</body>
</html> 